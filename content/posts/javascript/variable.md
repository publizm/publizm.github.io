---
title: 변수(Variable)
date: "2019-10-06"
template: "post"
draft: false
slug: "/posts/javascript/variable"
category: "Javascript"
tags:
  - "variable"
  - "var"
  - "let"
  - "const"
description: "Variable에 대해서 알아보자"
---
<span class="notice">
  <em>TIL 내용이므로 잘못된 내용은 댓글 부탁드립니다</em>
</span>

<div id="toc">

**:link:  Table Of Contents**

- [변수란?](#변수란)
- [변수 선언](#변수-선언)
  - [키워드](#키워드)
  - [식별자](#식별자)
- [변수선언의 시점과 호이스팅](#변수선언의-시점과-호이스팅)
- [변수 값의 할당과 재할당](#변수-값의-할당과-재할당)
  - [할당](#할당)
  - [재할당](#재할당)
- [언매니지드 언어와 매니지드 언어](#언매니지드-언어와-매니지드-언어)
  - [언매니지드 언어](#언매니지드-언어예를들어-c언어)
  - [매니지드 언어](#매니지드-언어예를들어-javascript)

</div>

## 변수란?

``` javascript
var a; // var(키워드, 명령어) 변수명(식별자, identifier)
```

변수(Variable, 식별자(identifier))는 하나의 값을 저장할 수 있는 **메모리 공간에 붙인 이름** 또는 **메모리 공간 자체**를 말한다. 변수에 여러개를 저장하지 못하는 이유는 두개 이상의 값을 넣으면 그 데이터를 참조할때 어느 값을 불러아야되는지 알 수 없기 때문이다. 그래서 배열이나 객체와 같은 자료 구조를 사용하면 관련이 있는 여러 개의 값을 그룹화하여 하나의 값처럼 사용한다.


> **메모리(memory)**<br>
메모리는 데이터를 저장할 수 있는 메모리 셀들의 집합체이다. 셀 하나의 크기는 1byte(8bit)이며 컴퓨터는 셀의 크기, 즉 1byte 단위로 데이터를 저장(write)하거나 읽어(read) 들인다. 컴퓨터는 모든 데이터를 2진수로 처리한다. 따라서 메모리에 저장되는 데이터는 데이터의 종류(숫자, 텍스트, 이미지, 동영상 등)와 상관없이 2진수다. 각각의 셀은 고유의 메모리 주소(memory address)를 갖는다. 이 메모리 주소는 메모리 공간의 위치를 나타내며 0부터 시작하여 메모리의 크기만큼 정수로 표현된다. 예를 들어 4GB의 메모리는 0부터 4,294,967,295(0x00000000 ~ 0xFFFFFFFF)까지의 메모리 주소를 갖는다.<br>
*메모리의 값을 가져올때 직접 메모리 주소를 불러와 참조를하면 컴퓨터에 위협을 줄 가능성이 높아지기 때문에 변수를 사용하여 주소의 이름을 부여해주는 것이다.*

<br>

**:bulb:Tips**<br>
- 메모리(RAM) - 기억하는 곳 (예를들어 RAM 4G는 메모리가 데이터를 4기가까지 기억할 수 있다는 뜻이다.)<br>
- CPU - 기억한 것을 연산하는 곳

<br>
<br>

## 변수 선언
변수 선언은 변수 이름을 자바스크립트 엔진에 알려 등록하고 변수 값을 저장하기 위한 메모리 영역의 확보를 명령하여 값을 저장할 수 있도록 준비하는 것을 의미한다.

> 변수의 값을 저장하는 것을 할당이라고 의미하고, 저장된 값을 읽어드리는 행위를 참조라고 한다.

``` javascript
var a;
```

**자바스크립트의 선언의 과정**
- 선언단계(Declaration phase): 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계(Initialization phase): 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined(원시값)를 할당한다.

<br>

### 키워드
키워드(keyword)는 자바스크립트 코드를 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. var 키워드가 실행되면 자바스크립트 엔진은 새로운 변수를 선언한다.

> **var에만 해당하는 특징**<br>
변수 선언만 해도 암묵적으로 자바스크립트 엔진은 undefined(원시값)을 변수에 할당하여 메모리가 만든 메모리의 공간에 넣어둔다.<br>
이유는 새롭게 만든 메모리에 예전에 쓰였던 메모리(Garbage Value)가 남아 있을 경우가 있기 때문에 초기화를 한다.

<hr class="sub" />

### 식별자

변수 이름을 식별자(identifier)라고도 부른다. 식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다.
식별자는 특별한 네이밍 규칙을 갖는다.
- 특수문자(**underscore(_), 달러 기호($)는 제외**)를 제외한 모든 문자, 숫자
- 첫글자(시작)은 특수문자(**underscore(_), 달러 기호($)는 제외**)를 제외한 모든 문자로 시작해야된다. **숫자로 시작되는 것은 허용하지 않는다**
- **예약어**는 식별자로 사용할 수 없다.

> **예약어**<br>
예약어(reserved word)는 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어들을 말한다. 자바스크립트의 예약어는 아래와 같다.<br>
await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* Switch this throw true try typeof var void while with yield*<br>
*식별자로 사용 가능하나 Strict Mode에서는 사용 불가

<br>
<br>

## 변수선언의 시점과 호이스팅

``` javascript
console.log(a); // undefined

var a;
```

위 예제를 보면 **변수 선언문(var a)보다 변수를 참조하는 코드(console.log(a))**가 먼저 쓰여져있다.
자바스크립트 코드는 한 줄씩 순차적으로 실행(런타임 환경)이므로 **참조하는 코드인 console.log(a);**가 가장 먼저 실행되고 순차적으로 다음 줄에 있는 코드를 실행한다.<br>
따라서 **참조해야될 대상이 없는 참조 코드(console.log(a))가 실행 되는 시점에 참조 에러(ReferenceError)가 발생해야 될 것 같이 보인다.**<br>
하지만 참조 에러(ReferenceError)는 발생하지 않고 **undefined**가 출력된다.
<br>

그 이유는 변수 선언(var a)이 소스 코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임(run-time)이 아니라 그 **이전 단계에서 먼저 실행**되기 때문이다.

> 자바스크립트 엔진은 소스 코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 코드의 평가 과정을 거치면서 코드 실행을 위한 준비를 한다. 이때, *코드 실행을 위한 준비 단계인 코드의 평가 과정에서 자바스크립트 엔진은 __변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스 코드에서 찾아내어 먼저 실행한다.(이를 호이스팅이라 한다.)__ 그리고 코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 코드가 한 줄씩 순차적으로 실행한다.*

즉, 자바스크립트 엔진은 변수 선언이 소스 코드의 위치에 상관없이 다른 코드보다 먼저 실행한다.

위에서 볼 수 있듯 변수 선언(선언 단계와 초기화 단계)이 소스 코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행된다는 것이다. 이처럼 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(Variable Hoisting)**이라 한다.<br>
호이스팅은 변수 선언 뿐만이 아니라 **var**, **let**, **const**, **function**, **class** 키워드를 사용하여 선언된 모든 식별자도 호이스팅된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

<br>
<br>

## 변수 값의 할당과 재할당
변수에 값을 할당(대입, 저장)할 때는 할당 연산자인 **=**를 사용한다.<br>
할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

<br>

### 할당
``` javascript
var a; // 변수 선언
a = 100 // 값의 할당

var b = 100; // 변수 선언과 동시에 값을 할당
```

위의 예제인 선언과 할당을 구분한 예제와 선언과 할당을 같이 한 예제는 정확히 동일하게 동작한다.<br>
이때 주의할 것은 변수 선언은 소스 코드가 순차적으로 실행되기 이전, 즉 런타임 이전에 먼저 실행되지만 **값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다**는 점이다.

``` javascript
console.log(a); // undefined
console.log(b); // undefined

var a = 100; // 변수 선언과 동시에 값의 할당

var b; // 변수 선언
b = 200; // 값의 할당

console.log(a);  // 100
console.log(b);  // 200

```

a와 b의 값을 할당하는 시점에는 이미 변수 선언이 완료된 상태이고 변수는 **undefined(원시값)**으로 초기화되어 있다. 따라서 변수 a,b에 값을 할당하면 변수 a,b의 값은 **undefined**에서 새롭게 할당된 숫자 값으로 변경(재할당)되는 것이다.<br>
*이렇듯 변수 선언과 값의 할당을 각각 실행했을 때와 변수의 선언과 값의 할당을 하나의 문으로 단축 표현했을 때 모두 동일하다는 것을 알 수 있다.*

<hr class="sub" />

### 재할당
이미 값이 할당되어 있는 변수에 새로운 값을 또 다시 할당하는 것을 말한다.

``` javascript
var a = 80; // 변수 선언과 동시에 값의 할당
a = 100; // 값의 재할당
```

**var**키워드로 선언한 변수의 값은 재할당 할 수 있다.<br>
**var**키워드로 선언한 변수는 선언과 동시에 **undefined(원시값)**으로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당이라고 볼 수 있다.<br>
<br>

재할당은 변수에 저장된 값을 다른 값으로 변경한다. 이때 다른 메모리를 사용하는데 최초 할당할때처럼 undefined(원시값)을 이용해서 공간을 부여하진 않고 **다른 셀**에 값을 대입해 다른 메모리 공간을 차지한다. *이전 변수의 값인 80은 어떠한 변수도 값으로 갖지 않게 되므로 더이상 필요하지 않다는 것을 의미한다. 이러한 불필요한 값들은 가비지 컬렉터(Garbage Collector)에 의해 메모리에서 자동 해제된다.*

**:exclamation: 주의할 점**<br>
재할당은 말이 재할당인거지 기존에 가지고 있던 원시값을 다른 내용으로 바꾸는 것이 아니라, 다른 메모리 셀에 변경 값을 저장하여 그곳을 가리키게 되는 것이다.

<br>

> **가비지 컬렉터(Garbage Collector)**<br>
애플리케이션이 확보한 메모리를 주기적으로 검사하여 더이상 사용되고 있지 않는 메모리를 해제하는 기능을 말한다. 자바스크립트는 가비지 컬렉터를 내장하고 있는 *매니지드 언어*이다. 이를 통해 메모리 누수를 방지한다.

<br>

## 언매니지드 언어와 매니지드 언어
프로그래밍 언어는 *메모리 관리 방식* 에 의해 언매니지드 언어와 매니지드 언어로 분류할 수 있다.

<br>

### 언매니지드 언어(예를들어 C언어)
개발자가 명시적으로 메모리를 할당하고 해제하기 위해 저수준(low-level) 메모리 관리 기능을 제공한다. 메모리 관리를 개발자가 주도하므로 개발자의 역량에 의해 최적의 퍼포먼스르 확보할 수 있지만 그 반대의 경우, 치명적 오류를 생산할 가능성도 동시에 존재한다.<br>

<hr class="sub" />

### 매니지드 언어(예를들어 Javascript)
메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는다. 즉, 개발자가 메모리를 할당하고 해제할 수 없다. 더이상 사용하지 않는 메모리의 해제는 **가비지 컬렉터**가 수행하며, 개발자가 관여할 수없다. 매니지드 언어는 개발자의 역량에 의존하는 부분이 상대적으로 작아져 어느 정도 일정한 생산성을 확보할 수 있는 장점이 있지만 퍼포먼스 면에서의 손실은 감수할 수 밖에 없다.

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<div class="reference-site">

  **Reference**<br>

  [https://poiemaweb.com](https://poiemaweb.com)

</div>
