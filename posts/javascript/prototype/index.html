<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.2e2bd0354ff5dde91452.css">@font-face{font-family:Cabin;font-style:normal;font-weight:700;src:url(/static/Cabin700-b6f2afea0ac60c21102c0e68d92074ab.woff) format("woff")}@font-face{font-family:FiraCode;font-style:normal;font-weight:300;src:url(/static/FiraCode300-577365043cbd0a566deb3eda6b97b6b3.woff) format("woff")}@font-face{font-family:FiraCode;font-style:normal;font-weight:400;src:url(/static/FiraCode400-b20fce1a0b4bae07b246957e761e20b9.woff) format("woff")}@font-face{font-family:FiraCode;font-style:normal;font-weight:500;src:url(/static/FiraCode500-05ade79bc864cdb0952976e62cd512d4.woff) format("woff")}@font-face{font-family:FiraCode;font-style:normal;font-weight:600;src:url(/static/FiraCode600-9bcb90b70963d481483f061875d8996b.woff) format("woff")}@font-face{font-family:FiraCode;font-style:normal;font-weight:700;src:url(/static/FiraCode700-f2220a495ad3c4492ecff55830226443.woff) format("woff")}@font-face{font-family:Notosans;font-style:normal;font-weight:100;src:url(/static/NotoSansKR100-0145261f3bb07f93d90ea6144cf3b674.woff) format("woff")}@font-face{font-family:Notosans;font-style:normal;font-weight:200;src:url(/static/NotoSansKR200-e63275d9b3a9ba2149a80d9e8cfc995f.woff) format("woff")}@font-face{font-family:Notosans;font-style:normal;font-weight:300;src:url(/static/NotoSansKR300-d2993642099fb347f5ea312181ac0cd6.woff) format("woff")}@font-face{font-family:Notosans;font-style:normal;font-weight:400;src:url(/static/NotoSansKR400-45c14df05640199a3f39c0e4602e8ff1.woff) format("woff")}@font-face{font-family:Notosans;font-style:normal;font-weight:500;src:url(/static/NotoSansKR500-fe9440710fd61314e5fdb56a7a149290.woff) format("woff")}@font-face{font-family:Notosans;font-style:normal;font-weight:700;src:url(/static/NotoSansKR700-317a73f1be1bdbaa86291c36079f09de.woff) format("woff")}@font-face{font-family:Notosans;font-style:normal;font-weight:900;src:url(/static/NotoSansKR900-df912f6e5bd43efe42b780dd9e5cf08d.woff) format("woff")}::selection{background:#475aab;color:#fff}::-moz-selection{background:#475aab;color:#fff}html{font-size:100}body{margin:0 0 0 calc(100vw - 100%);color:#222;line-height:2;font-size:.9375rem;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}body,h1,h2,h3,h4,h5,h6{font-family:Notosans,sans-serif}h1,h2,h3,h4,h5,h6{word-break:keep-all}h1{font-size:2.34375rem;font-weight:700;margin-top:8rem;margin-bottom:2rem}h1,h2{line-height:2.4rem}h2{font-weight:600;font-size:1.76953rem;margin-top:4rem;margin-bottom:1.6rem}h3{font-weight:500;font-size:1.5rem}h3,h4{line-height:2.4rem;margin-top:1rem;margin-bottom:1rem}h4{font-weight:400;font-size:1.3125rem}h5{font-size:1.19531rem}h5,h6{font-weight:400;line-height:2rem;margin-top:1rem;margin-bottom:1rem}h6{font-size:1.125rem}img{max-width:100%;margin:inherit auto}hr,img{border:0;display:block}hr{color:#222;height:26px;margin:3.25rem auto;background-size:100% 26px;background-image:linear-gradient(180deg,transparent 1px,transparent 11px,#222 0,#222 15px,transparent 0,transparent 26px);width:6.25rem}hr.sub{width:100%;height:5px;background:none;border-bottom:2px dotted #dedede}a{color:#5d93ff;text-decoration:none}a:active,a:focus,a:hover{color:#f7a046}b,strong{font-weight:600}ul{list-style:square;margin-bottom:1rem}ul li{padding:0 .3125rem;margin-bottom:.625rem}ul li ul{list-style:disc}ul li ul li ul{list-style:circle}p{line-height:2rem;margin-bottom:1rem}blockquote{padding:0;font-style:italic;text-align:center}figure{display:block;width:100%;height:auto}figcaption{line-height:1.5rem;margin-top:.5rem;color:#222;font-size:.75rem;font-style:italic;margin-bottom:0;text-align:center}.anchor{margin-left:-1.875rem!important;padding-right:.875rem!important}@media screen and (min-width:685px){figure.float-left,figure.float-right{max-width:19.375rem;padding:0 2rem}.float-right{float:right}.float-left{float:left}}.board-tbl{overflow-x:auto;width:100%}.board-tbl table{width:100%;border-collapse:collapse}.board-tbl table thead th{min-width:30px;padding:1em;background:#344ae8;font-weight:400;font-size:.9rem;line-height:1.8rem;color:#fff}.board-tbl table thead th:first-child{border-radius:.9375rem 0 0 0}.board-tbl table thead th:last-child{border-radius:0 .9375rem 0 0}.board-tbl table thead tr.radius-none th{border-radius:0}.board-tbl table tbody td,.board-tbl table tbody th{min-width:30px;padding:1em;font-size:.9rem;line-height:1.8rem;border-bottom:2px solid #ececf3}.board-tbl table tbody td{word-break:keep-all}.browser-tbl{overflow-x:auto;width:100%}.browser-tbl table{border-collapse:collapse;margin-left:0}.browser-tbl table thead th{min-width:30px;width:1.875rem;padding:1em 1.3em;background:#282828;font-weight:500;font-size:1rem;color:#fff}.browser-tbl table thead th:first-child{border-radius:.9375rem 0 0 0}.browser-tbl table thead th:last-child{border-radius:0 .9375rem 0 0}.browser-tbl table tbody td,.browser-tbl table tbody th{min-width:30px;padding:1em;border-bottom:3px solid #f2f2f2}.browser-tbl table tbody td{font-size:1rem;word-break:keep-all}.category-list{margin:0;padding:0;list-style:none}.category-list li{display:inline-block;margin:0 2em 2em 0;padding:0}.category-list li:last-child{margin-right:0}.category-list li a{display:block;padding:.3em 1.2em;border-radius:0;color:#222;font-weight:400;font-size:.9375rem;letter-spacing:.0625rem;text-transform:uppercase;text-decoration:none;position:relative;transition:all .25s ease}.category-list li a:after,.category-list li a:before{content:"";position:absolute;left:0;top:0;width:100%;height:100%;border:1px solid #0e2ba4;transition:.25s}.category-list li a:before{z-index:-1;transform:translateX(-.2em) translateY(.2em)}.category-list li a:after{z-index:-1;transform:translateX(.2em) translateY(-.2em)}.category-list li a:hover{background:#0e2ba4;color:#fff}.category-list li a:hover:after,.category-list li a:hover:before{background:#0e2ba4;transform:translateX(0) translateY(0)}.reference-site p{margin:0!important;font-size:.9375rem!important}.reference-site p a{display:inline-block;word-break:break-all}.Content-module--content__body--2bfha blockquote{position:relative;box-sizing:border-box;padding:.6em 1.5em;border-left:.4em solid #4259ba;background:#f6f8fa;font-style:normal;text-align:left;color:#a1a1a1}.Content-module--content__body--2bfha blockquote>*{margin:0!important;font-size:.9rem!important}.Content-module--content__body--2bfha blockquote b{background:#dedede;color:#87888e}.Content-module--content__body--2bfha .notice{display:block;text-align:center;word-break:keep-all}.Content-module--content__body--2bfha .notice em{display:inline-block;position:relative;padding:1.5em 2.2em;font-style:normal;font-size:1.21875rem;color:#b3b3b3}.Content-module--content__body--2bfha .notice em:after,.Content-module--content__body--2bfha .notice em:before{font-family:Cabin;position:absolute;font-size:4.6875rem;height:45px;line-height:1}.Content-module--content__body--2bfha .notice em:before{content:"\201C";top:0;left:0}.Content-module--content__body--2bfha .notice em:after{content:"\201D";bottom:0;right:0}.Content-module--content__body--2bfha strong{font-weight:500;text-decoration:underline;text-underline-position:under}b{padding:.1em .2em;border-radius:.3125rem;background:#b0f1ff;font-weight:400;color:rgba(22,75,120,.65)}#toc{box-sizing:border-box;margin-bottom:2rem;margin-top:1rem;padding:0 .7rem;border:2px dotted #eee;background:#f8f8f9}#toc strong{font-size:1.3rem;text-decoration:none}#toc ul{margin-top:.5rem}#toc ul,#toc ul li{margin-bottom:.5rem}#toc ul li ul li{font-size:.95rem;line-height:1.9rem}#toc ul li a{font-weight:400;color:#585858;transition:color .3s}#toc ul li a:hover{color:#5d93ff}.gatsby-resp-image-image{box-shadow:0 0 10px 5px #eee}code[class*=language-],pre[class*=language-]{color:#ccc;font-family:FiraCode;font-size:.9em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em;background-color:#2d2d2d;color:#ccc}:not(pre)>code[class*=language-]{padding:.2em .3em;border-radius:.3em;background:#91a8d0;font-weight:400;color:#fff}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.Author-module--author__photo--HnDWV{display:inline-block;margin-bottom:0;border-radius:50%;background-clip:padding-box}.Author-module--author__title--ZztQd{font-size:1.05469rem;font-weight:600;line-height:2.25rem;margin:1rem 0}.Author-module--author__title-link--BY7f8,.Author-module--author__title-link--BY7f8:focus,.Author-module--author__title-link--BY7f8:hover{color:#222}.Author-module--author__subtitle--3hbMX{color:#888;line-height:2rem;margin-bottom:2rem}.Icon-module--icon--1T2h2{display:inline-block;width:1em;height:1em;stroke-width:0;stroke:currentColor;fill:currentColor;font-style:normal;font-weight:400;speak:none;margin-right:.2em;text-align:center;font-variant:normal;text-transform:none;line-height:1em;margin-left:.2em;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.Contacts-module--contacts--3fb7G{margin-bottom:2rem}.Contacts-module--contacts__list--27zok{display:flex;flex-flow:row wrap;flex-grow:0;flex-shrink:0;list-style:none;padding:0;margin:.625rem -.1875rem;width:8.75rem}.Contacts-module--contacts__list-item--1Adud{padding:0;margin:.25rem;display:flex;align-content:center;align-items:center;justify-content:center;height:35px;width:2.1875rem;line-height:2.1875rem;border-radius:50%;text-align:center;border:1px solid #ebebeb}.Contacts-module--contacts__list-item-link--2L60c{border:0;display:flex;color:#222}.Contacts-module--contacts__list-item-link--2L60c:focus,.Contacts-module--contacts__list-item-link--2L60c:hover{color:#5d93ff}.Copyright-module--copyright--1YLES{color:#b6b6b6;font-size:.75rem}.Menu-module--menu--2aN3O{margin-bottom:2rem}.Menu-module--menu__list--1uKDu{list-style:none;padding:0;margin:0}.Menu-module--menu__list-item--27cxj{padding:0;margin:.625rem 0}.Menu-module--menu__list-item-link--29Sd-{font-size:.9375rem;color:#222;font-weight:400;border:0}.Menu-module--menu__list-item-link--29Sd-:focus,.Menu-module--menu__list-item-link--29Sd-:hover{color:#5d93ff;border-bottom:1px solid #5d93ff}.Menu-module--menu__list-item-link--active--2HzKy{color:#222;border-bottom:1px solid #222}.Sidebar-module--sidebar--1zM7S{width:100%}.Sidebar-module--sidebar__inner--2Tprz{position:relative;padding:1.5625rem 1.25rem 0}@media screen and (min-width:685px){.Sidebar-module--sidebar--1zM7S{width:calc(41.625% - 1.09375rem)}.Sidebar-module--sidebar--1zM7S:nth-child(1n){float:left;margin-right:1.875rem;clear:none}.Sidebar-module--sidebar--1zM7S:last-child{margin-right:0}.Sidebar-module--sidebar--1zM7S:nth-child(12n){margin-right:0;float:right}.Sidebar-module--sidebar--1zM7S:nth-child(12n+1){clear:both}.Sidebar-module--sidebar__inner--2Tprz{padding:1.875rem 1.25rem 0}.Sidebar-module--sidebar__inner--2Tprz:after{background:#e6e6e6;background:-webkit-gradient(linear,left top,left bottom,from(#e6e6e6),color-stop(48%,#e6e6e6),to(#fff));background:linear-gradient(180deg,#e6e6e6 0,#e6e6e6 48%,#fff);position:absolute;content:"";width:.0625rem;height:540px;top:30px;right:-10px;bottom:0}}@media screen and (min-width:960px){.Sidebar-module--sidebar--1zM7S{width:calc(33.3% - 1.25rem)}.Sidebar-module--sidebar--1zM7S:nth-child(1n){float:left;margin-right:1.875rem;clear:none}.Sidebar-module--sidebar--1zM7S:last-child{margin-right:0}.Sidebar-module--sidebar--1zM7S:nth-child(3n){margin-right:0;float:right}.Sidebar-module--sidebar--1zM7S:nth-child(3n+1){clear:both}.Sidebar-module--sidebar__inner--2Tprz{padding:2.5rem}}.Layout-module--layout--EpQHE{max-width:66.875rem;margin-left:auto;margin-right:auto}.Layout-module--layout--EpQHE:before{content:"";display:table}.Layout-module--layout--EpQHE:after{content:"";display:table;clear:both}.Feed-module--feed__item--Bm0MP{margin-bottom:2.5rem}.Feed-module--feed__item--Bm0MP:last-child{margin-bottom:1rem}.Feed-module--feed__item-title--34sOw{font-size:1.58203rem;line-height:2.4rem;margin-top:.6rem;margin-bottom:.6rem}.Feed-module--feed__item-title-link--2qfTF{color:#222}.Feed-module--feed__item-title-link--2qfTF:focus,.Feed-module--feed__item-title-link--2qfTF:hover{color:#222;border-bottom:1px solid #222}.Feed-module--feed__item-description--2_Zuy{font-size:.9375rem;line-height:2rem;margin-bottom:1.5rem}.Feed-module--feed__item-meta-time--3hc6b{font-size:.75rem;color:#222;font-weight:600;text-transform:uppercase}.Feed-module--feed__item-meta-divider--2GeAw{margin:0 .3125rem}.Feed-module--feed__item-meta-category-link--lAu1I{font-size:.75rem;color:#f7a046;font-weight:600;text-transform:uppercase}.Feed-module--feed__item-meta-category-link--lAu1I:focus,.Feed-module--feed__item-meta-category-link--lAu1I:hover{color:#5d93ff}.Feed-module--feed__item-readmore--rMfbv{font-size:.9375rem;color:#5d93ff}.Feed-module--feed__item-readmore--rMfbv:focus,.Feed-module--feed__item-readmore--rMfbv:hover{color:#5d93ff;border-bottom:1px solid #5d93ff}.Page-module--page--V2155{margin-bottom:4rem}.Page-module--page__inner--3xzwp{padding:1.5625rem 1.25rem}.Page-module--page__title--t1zKX{font-size:2.34375rem;font-weight:600;line-height:4rem;margin-top:0;margin-bottom:2.9rem}.Page-module--page__body--1A7TB{font-size:.9375rem;line-height:2rem;margin:0 0 2rem}@media screen and (min-width:685px){.Page-module--page--V2155{width:calc(58.275% - .78125rem)}.Page-module--page--V2155:nth-child(1n){float:left;margin-right:1.875rem;clear:none}.Page-module--page--V2155:last-child{margin-right:0}.Page-module--page--V2155:nth-child(12n){margin-right:0;float:right}.Page-module--page--V2155:nth-child(12n+1){clear:both}.Page-module--page__inner--3xzwp{padding:1.875rem 1.25rem}}@media screen and (min-width:960px){.Page-module--page--V2155{width:calc(66.6% - .625rem)}.Page-module--page--V2155:nth-child(1n){float:left;margin-right:1.875rem;clear:none}.Page-module--page--V2155:last-child{margin-right:0}.Page-module--page--V2155:nth-child(3n){margin-right:0;float:right}.Page-module--page--V2155:nth-child(3n+1){clear:both}.Page-module--page__inner--3xzwp{padding:2.5rem 2.1875rem}}.Pagination-module--pagination--3T_m0{margin-top:4rem;display:flex}.Pagination-module--pagination__prev--3tRFv{width:50%;text-align:left}.Pagination-module--pagination__prev-link--2vesn{color:#f7a046;font-size:1.625rem;font-weight:700}.Pagination-module--pagination__prev-link--2vesn:focus,.Pagination-module--pagination__prev-link--2vesn:hover{color:#5d93ff}.Pagination-module--pagination__prev-link--disable--1Fxw2{pointer-events:none;color:#bbb}.Pagination-module--pagination__next--19bJd{width:50%;text-align:right}.Pagination-module--pagination__next-link--3ln7y{color:#f7a046;font-size:1.625rem;font-weight:700}.Pagination-module--pagination__next-link--3ln7y:focus,.Pagination-module--pagination__next-link--3ln7y:hover{color:#5d93ff}.Pagination-module--pagination__next-link--disable--AsM50{pointer-events:none;color:#bbb}.Author-module--author--2kf8a{border-top:1px solid #e6e6e6;max-width:46.5625rem;padding-top:1.25rem;line-height:2rem;margin-top:2rem;margin-bottom:4rem}.Author-module--author__bio-twitter--MufFK{display:block;text-decoration:underline}@media screen and (min-width:685px){.Author-module--author--2kf8a{margin-left:auto;margin-right:auto}}.Content-module--content--1tfQQ{max-width:59.0625rem;padding:0 .9375rem;margin:0 auto}.Content-module--content__title--1qFLI{font-size:1.875rem;max-width:46.5625rem;font-weight:600;text-align:center;line-height:3.3rem;margin:2rem auto 0}.Content-module--content__body--2bfha *{word-break:break-all}.Content-module--content__body--2bfha figure{margin-bottom:2rem}.Content-module--content__body--2bfha figure blockquote{font-style:italic;text-align:center;margin-top:0;padding:2rem 0}.Content-module--content__body--2bfha figure blockquote p{max-width:46.5625rem;font-size:1.57659rem;margin-top:0;margin-bottom:2rem;line-height:3rem}.Content-module--content__body--2bfha ul li p{margin:0}.Content-module--content__body--2bfha ul ul{margin-top:1rem;margin-bottom:1rem}.Content-module--content__body--2bfha a{font-weight:500}.Content-module--content__body--2bfha *{max-width:46.5625rem;margin-left:auto;margin-right:auto}.Content-module--content__body--2bfha img{max-width:100%}.Content-module--content__body--2bfha h2{padding:0 0 .6rem;border-bottom:.12em solid #4a568c}.Content-module--content__body--2bfha h3:before,.Content-module--content__body--2bfha h4:before{margin-right:.3em;font-weight:700;color:#0d2bab}.Content-module--content__body--2bfha h3:before{content:"#"}.Content-module--content__body--2bfha h4:before{font-weight:500;content:"##"}@media screen and (min-width:960px){.Content-module--content--1tfQQ{padding:0}.Content-module--content__title--1qFLI{font-size:2.8125rem;line-height:4.5rem;margin-top:4.5rem;margin-bottom:3rem}.Content-module--content__body--2bfha{margin-bottom:2.25rem}.Content-module--content__body--2bfha,.Content-module--content__body--2bfha p{font-size:1.05469rem;line-height:2.25rem}}.Meta-module--meta__date--3FNDv{font-style:italic}.Tags-module--tags--1oNz4{margin-bottom:1rem}.Tags-module--tags__list--2UTD-{list-style:none;margin:0 -.625rem;padding:0}.Tags-module--tags__list-item--b7tap{display:inline-block;margin:.625rem .3125rem}.Tags-module--tags__list-item-link--1hQL0{display:inline-block;height:35px;padding:0 1.5rem;line-height:2.1875rem;border:1px solid #e6e6e6;text-decoration:none;border-radius:1.25rem;color:#222}.Tags-module--tags__list-item-link--1hQL0:focus,.Tags-module--tags__list-item-link--1hQL0:hover{color:#5d93ff}.Post-module--post__comments--2T8dL,.Post-module--post__footer--1BvmJ{max-width:46.5625rem;margin:0 auto;padding:0 .9375rem}.Post-module--post__home-button--3zx_9{display:block;max-width:5.625rem;height:35px;padding:0 1.5rem;line-height:2.1875rem;text-align:center;color:#222;border:1px solid #e6e6e6;border-radius:1.25rem;font-size:.9375rem;font-weight:400;margin-left:auto;margin-right:auto;margin-top:2rem}.Post-module--post__home-button--3zx_9:focus,.Post-module--post__home-button--3zx_9:hover{color:#5d93ff}@media screen and (min-width:960px){.Post-module--post__comments--2T8dL,.Post-module--post__footer--1BvmJ{padding:0}.Post-module--post__home-button--3zx_9{position:fixed;max-width:auto;margin:0;top:30px;left:30px;background:#fff;z-index:1}}</style><meta name="generator" content="Gatsby 2.15.9"/><link rel="alternate" type="application/rss+xml" title="Publee&#x27;s velog" href="/rss.xml"/><style type="text/css">.gatsby-resp-image-image{width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;color:transparent;}</style><style type="text/css">
    .anchor {
      float: left;
      padding-right: 4px;
      margin-left: -20px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var offset = element.offsetTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="preconnect dns-prefetch" href="https://www.google-analytics.com"/><link rel="preconnect dns-prefetch" href="https://www.google-analytics.com"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-73379983-2"></script><script>
      
      
      if(true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){window.dataLayer && window.dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-73379983-2', {"send_page_view":false});
      }
      </script><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><link rel="shortcut icon" href="/icons/icon-48x48.png?v=f3f97527b0ae54b1a81acd2493cb5188"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#F7A046"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=f3f97527b0ae54b1a81acd2493cb5188"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=f3f97527b0ae54b1a81acd2493cb5188"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=f3f97527b0ae54b1a81acd2493cb5188"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=f3f97527b0ae54b1a81acd2493cb5188"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=f3f97527b0ae54b1a81acd2493cb5188"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=f3f97527b0ae54b1a81acd2493cb5188"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=f3f97527b0ae54b1a81acd2493cb5188"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=f3f97527b0ae54b1a81acd2493cb5188"/><title data-react-helmet="true">프로토타입(Prototype) - Publee&#x27;s velog</title><meta data-react-helmet="true" name="description" content="프로토타입에 대해서 알아보자"/><meta data-react-helmet="true" property="og:site_name" content="프로토타입(Prototype) - Publee&#x27;s velog"/><meta data-react-helmet="true" property="og:image" content="https://publizm.github.io//images/publee.png"/><link as="script" rel="preload" href="/webpack-runtime-3b57bb17d138b785ccb6.js"/><link as="script" rel="preload" href="/app-b5ef2b8caa37ca4e0f53.js"/><link as="script" rel="preload" href="/styles-fbc6349a203ed4bcd9e6.js"/><link as="script" rel="preload" href="/commons-d334a8000d62581fb129.js"/><link as="script" rel="preload" href="/component---src-templates-post-template-js-101fb2c27a0a2ef5a3cd.js"/><link as="fetch" rel="preload" href="/page-data\posts\javascript\prototype\page-data.json" crossorigin="anonymous"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div class="Layout-module--layout--EpQHE"><div><a class="Post-module--post__home-button--3zx_9" href="/">All Articles</a><div><div class="Content-module--content--1tfQQ"><h1 class="Content-module--content__title--1qFLI">프로토타입(Prototype)</h1><div class="Content-module--content__body--2bfha"><span class="notice">
  <em>TIL 이므로 잘못된 내용은 댓글 부탁드립니다</em>
</span>
<div id="toc">
<p><strong><img class="emoji-icon" alt="emoji-link" data-icon="emoji-link" style="display: inline; margin: 0; margin-top: 1px; position: relative; top: 5px; width: 25px" src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAABGdBTUEAAYagMeiWXwAAAAJiS0dEAP+Hj8y/AAAAB3RJTUUH4QsFFwYZepoZFwAAA21JREFUOMt1lFtsFHUUxr//zHYue213obFbamutloDaxSigISQYkFrjNSSI9EJ9IWqjkZhoUkVJGhdZO5pGm9IK4QHhQTRIFXwgxqSaWLykamAV02btZaft7navc9vZmb8PKFa6nofz9Ptycr5zIfif+BMcE23Q79SrkSK/uqYqrG0AAFIePw3ep+zXus0Ghrd1Msmfcn5oJ/YCYMvhI6D+uJQ84PCsvhwcZ5Xc2uSDmbqFse1qrJxgGLxflvL7hDn60uLBn04rn9hXrZbMFi0T/uaJlYIhiP64pHSJ00s9b34saietonbil8Y0adNr15+z8+yNOOeXJbVLiC319H++EV8DmEEb0jK3E7ep5+1px3L8AH5zed+2O2HGT23+jpJJ2gQAsJDPBVI8V3QRMP/i3VA8xsu5do1ccTDPpT478cyE5yQAIIjbA0ItDGNJw/UKR+D2/xgpdhB2Pto40xxU75ltYdaZhw7leDxJhnYb67TvlamKf5o+Cr9/VprdR1l7IbnbN2B9as1bGzP3a7Gqic3kq6eNPoFR+x79NnpNMASnPy7lOpUMZUjeGMwlErlL46JFHtIC8qj+eP490YfIlUG5dBYscBS8X5aULn460cs2CHXiRdekAxzNyuzDtH5BIK9UViISC9foxwGwryLjVvr1bnEm2zNyJtTs2Sr4GsYc+QJMq+Ixuja2Kci7I1fDbm0QAMDuRK7D6OXns89Lox3UlKu3iluE9bcWmpj4XfxeszJZcr9DDkMb/tsc0u7lzwrb1BePD2yCFxfJC631b7EtRWM6nRQCVXJ+or82UlTHr5vv0OuZptKc/EUbLgF4hA58+Vqsrt16AKEaQVAWe6eGsmZq2XAZw22LlsKo1/wdBSiNzh0sfOS1q4pEmh/e9R8cYEqLWOIDN928Cs8CAD7ABsb7lPm64LAik4ebjTM3LCdbqa4Oee4TmTvGbP0cNuBu5uc96Xd5H41MhH3qsRXLz263SvlAq/NeUt+YShDhluj+xBucl0b+CAfUkTLHRXYhyu7oXNPH1tAskyJeexVbUPp/P+LW3i97vAQcOMHduiO0Z03I6TFNOf7DhfMXVB0ENiyYMKBDhYYiTNiwCTg44YLI+5qrg540vawUTDAgoLBRQhE6VChQoMGEBZss+x0UAFnxR+iyDOAv/Ud+TW3GONMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMTEtMDVUMTg6NDk6NTArMDA6MDAUXGOwAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTExLTA1VDEzOjUzOjQ4KzAwOjAwqyFlXwAAAABJRU5ErkJggg==" title="emoji-link">  Table Of Contents</strong></p>
<ul>
<li><a href="#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80">객체지향 프로그래밍이란?</a></li>
<li><a href="#%EC%83%81%EC%86%8D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85">상속과 프로토타입</a></li>
<li>
<p><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4">프로토타입 객체</a></p>
<ul>
<li>
<p><a href="#__-proto-__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0">__ proto __ 접근자 프로퍼티</a></p>
<ul>
<li><a href="#__-proto-__%EB%8A%94-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%9D%B4%EB%8B%A4">__ proto __는 접근자 프로퍼티이다.</a></li>
<li><a href="#__-proto-__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%8A%94-%EC%83%81%EC%86%8D%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%82%AC%EC%9A%A9%EB%90%9C%EB%8B%A4">__ proto __ 접근자 프로퍼티는 상속을 통해 사용된다.</a></li>
<li><a href="#__-proto-__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%ED%86%B5%ED%95%B4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0">__ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유</a></li>
<li><a href="#__-proto-__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EC%BD%94%EB%93%9C-%EB%82%B4%EC%97%90%EC%84%9C-%EC%A7%81%EC%A0%91-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%B9%84%EC%B6%94%EC%B2%9C%EC%9D%B4%EB%8B%A4">__ proto __ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천이다.</a></li>
</ul>
</li>
<li><a href="#%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EC%9D%98-prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0">함수 객체의 prototype 프로퍼티</a></li>
<li><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-constructor-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98">프로토타입의 constructor 프로퍼티와 생성자 함수</a></li>
</ul>
</li>
<li><a href="#%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%91%9C%EA%B8%B0%EB%B2%95%EC%97%90-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85">리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</a></li>
<li>
<p><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EC%83%9D%EC%84%B1-%EC%8B%9C%EC%A0%90">프로토타입의 생성 시점</a></p>
<ul>
<li><a href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%83%9D%EC%84%B1%EC%8B%9C%EC%A0%90">사용자 정의 생성자 함수와 프로토타입 생성시점</a></li>
<li><a href="#%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%83%9D%EC%84%B1%EC%8B%9C%EC%A0%90">빌트인 생성자 함수와 프로토타입 생성시점</a></li>
<li>
<p><a href="#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B2%B0%EC%A0%95">객체 생성 방식과 프로토타입의 결정</a></p>
<ul>
<li><a href="#%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%97%90-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85">객체 리터럴에 의해 생성된 객체의 프로토타입</a></li>
<li><a href="#object-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85">Object 생성자 함수에 의해 생성된 객체의 프로토타입</a></li>
<li><a href="#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%A0%95%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85">사용자정의 생성자 함수에 의해 생성된 객체의 프로토타입</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8">프로토타입 체인</a></li>
<li><a href="#%EC%BA%A1%EC%8A%90%ED%99%94">캡슐화</a></li>
<li><a href="#%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%89%90%EB%8F%84%EC%9E%89">오버라이딩과 프로퍼티 쉐도잉</a></li>
<li>
<p><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B5%90%EC%B2%B4">프로토타입의 교체</a></p>
<ul>
<li><a href="#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B5%90%EC%B2%B4">생성자 함수에 의한 프로토타입의 교체</a></li>
<li><a href="#%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%97%90-%EC%9D%98%ED%95%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B5%90%EC%B2%B4">인스턴스에 의한 프로토타입의 교체</a></li>
</ul>
</li>
<li><a href="#instanceof-%EC%97%B0%EC%82%B0%EC%9E%90">instanceof 연산자</a></li>
<li>
<p><a href="#%EC%A7%81%EC%A0%91-%EC%83%81%EC%86%8D">직접 상속</a></p>
<ul>
<li><a href="#objectcreate%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A7%81%EC%A0%91-%EC%83%81%EC%86%8D">Object.create에 의한 직접 상속</a></li>
<li><a href="#%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-proto%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A7%81%EC%A0%91-%EC%83%81%EC%86%8D">객체 리터럴 내부에서 proto에 의한 직접 상속</a></li>
</ul>
</li>
<li><a href="#%EC%A0%95%EC%A0%81-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A9%94%EC%86%8C%EB%93%9C">정적 프로퍼티/메소드</a></li>
<li><a href="#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A1%B4%EC%9E%AC-%ED%99%95%EC%9D%B8">프로퍼티 존재 확인</a></li>
<li>
<p><a href="#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%97%B4%EA%B1%B0">프로퍼티 열거</a></p>
<ul>
<li><a href="#forin%EB%AC%B8">for…in문</a></li>
<li><a href="#objectkeysvaluesentries-%EB%A9%94%EC%86%8C%EB%93%9C">Object.keys/values/entries 메소드</a></li>
</ul>
</li>
</ul>
</div>
<p>자바스크립트는 <strong>프로토타입 기반 객체지향 프로그래밍 언어</strong>이고, 자바스크립트를 이루고 있는 거의 <strong>모든 것</strong>이 객체이다.</p>
<p><em>프로토 타입에 설명에 들어가기 앞서 객체지향 프로그래밍을 사전 지식으로 알고 있어야된다.</em></p>
<h2 id="객체지향-프로그래밍이란"><a href="#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80" aria-label="객체지향 프로그래밍이란 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>객체지향 프로그래밍이란?</h2>
<p>프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 프로그램을 여러 개의 독립적 단위, 즉 객체들의 집합으로 표현하려는 프로그래밍 패러다임을 말한다. 객체지향 프로그래밍은 사람이 주변의 실세계에서 사물이나 개념을 이해하는 방식을 프로그래밍에 접목하려는 사상에서 시작했다.</p>
<p>사람은 어떠한 사물이나 개념을 이해할 때 속성(attribute, property), 즉 특징이나 성질을 통해 이해하는 경향이 있다. 즉, 속성을 통해 어떠한 사물이나 개념을 구체화한다. 예를 들어 사람은 이름, 주소, 성별, 나이, 신장, 체중, 학력, 성격, 직업 등 다양한 속성을 갖는다. A라는 사람을 설명할 때 “이름이 아무개이고 성별은 여성이며 나이는 20세이다”라는 식으로 속성을 나열할 수 있다. 이 설명을 들은 사람은 이름, 성별, 나이라는 속성을 통해 부분적이나마 A라는 사람을 구체적으로 이해한다.</p>
<p>이러한 관점을 프로그래밍에 접목해보면, 사람에게는 다양한 속성이 있으나 우리가 구현하려는 프로그램에서는 사람의 “이름”, “성별”이라는 속성에만 관심이 있다고 가정해보자. 이처럼 <b>다양한 속성 중에서 프로그램에 필요한 속성만을 간추려 내어 표현하는 것을 “추상화”라고 한다.</b></p>
<p><strong>위 예시를 자바스크립트로 표현해보면</strong></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Lee'</span><span class="token punctuation">,</span>
  gender<span class="token punctuation">:</span> <span class="token string">'male'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: "Lee", gender: "male"}</span></code></pre></div>
<p>이처럼 우리는 사람의 속성(상태)를 프로퍼티로 표현할 수 있다.</p>
<p><strong>다른 예시를 살펴보자</strong></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> circle <span class="token operator">=</span> <span class="token punctuation">{</span>
  radius<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment">// 반지름</span>

  <span class="token comment">// 원의 지름</span>
  <span class="token function">getDiameter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>radius<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 원의 둘레</span>
  <span class="token function">getPerimeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>radius<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 원의 넓이</span>
  <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// === ES5 Math.pow(this.radius, 2);</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 대부분의 행위가 상태값에 의존하고 있다.</span>
<span class="token comment">// 함수형은 외부형태를 안 바꾸려하고, 객체형은 외부상태를 적극적으로 바꾸려한다.</span>
<span class="token comment">// 객체지향의 단점은 상태의 변화를 감지하기 어렵다.</span></code></pre></div>
<p>이번에는 원(Circle)이라는 개념을 객체로 만들어 보았다. 원에는 반지름이라는 속성이 있고, 이 반지름을 가지고 우리는 원의 지름, 둘레, 넓이를 구할 수 있다.</p>
<p>이처럼 객체지향 프로그래밍은 객체의 상태(state)를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작(behavior)을 하나의 논리적인 단위로 묶어 생각한다.<br>
이때 <b>상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조를 객체라 한다.</b></p>
<p>상속의 상위 개념이 객체지향이다.
객체는 상태를 나타내는 속성과 값, 그리고 상태를 동작하는 메소드가 있다. 각자의 객체는 독립적이지만 관계를 맺는다.</p>
<br>
<h2 id="상속과-프로토타입"><a href="#%EC%83%81%EC%86%8D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85" aria-label="상속과 프로토타입 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>상속과 프로토타입</h2>
<p>각각의 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만, <strong>자신의 고유한 기능을 수행하면서 다른 객체와 관계성을 가질수 있다.</strong> 예를들어 다른 객체와 메시지를 주고 받거나 데이터를 처리할 수도 있고, 다른 객체의 상태 데이터나 동작을 상속 받아 사용하기도 한다.</p>
<p><b>상속은 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.</b></p>
<p><strong>예제를 살펴보자</strong></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token parameter">radius</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>radius <span class="token operator">=</span> radius<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getArea</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>radius<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 인스턴스 생성</span>
<span class="token keyword">const</span> circle1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> circle2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> circle3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// getArea 메소드를 중복 생성하고 모든 인스턴스가 중복 소유한다.</span>
<span class="token comment">// 한마디로 깊은 복사가 되는 것이다.</span>
<span class="token comment">// 따라서 getArea 메소드는 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>circle1<span class="token punctuation">.</span>getArea <span class="token operator">===</span> circle2<span class="token punctuation">.</span>getArea<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false  &lt;- 인스턴스가 다르기 때문에 주소값이 다르다. 객체는 주소 값을 비교한다.</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>circle1<span class="token punctuation">.</span>radius <span class="token operator">===</span> circle3<span class="token punctuation">.</span>radius<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true &lt;- 원시값은 값을 비교한다.</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>circle1<span class="token punctuation">.</span><span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3.141592653589793</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>circle2<span class="token punctuation">.</span><span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12.566370614359172</span></code></pre></div>
<p><strong>그림으로 알아보자</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/1e82271c3fe0608bca3c798747a1f254/a1b4d/prototype_deepcopy.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHtzqiVj//EABgQAAIDAAAAAAAAAAAAAAAAAAABEiAh/9oACAEBAAEFAmzUSp//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGH/8QAGBAAAgMAAAAAAAAAAAAAAAAAADEBIEH/2gAIAQEABj8CRsip/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAERUWFx/9oACAEBAAE/IWtRN6Rqd4FaIsIRYf/aAAwDAQACAAMAAAAQJC//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCH/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8QI//EABwQAAICAgMAAAAAAAAAAAAAAAABESFhgTFRkf/aAAgBAQABPxBmQ4NCsDXY7FbQ4uHgllTejEP/2Q=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="deepcopy"
        title="deepcopy"
        src="/static/1e82271c3fe0608bca3c798747a1f254/aa03c/prototype_deepcopy.jpg"
        srcset="/static/1e82271c3fe0608bca3c798747a1f254/31ba1/prototype_deepcopy.jpg 186w,
/static/1e82271c3fe0608bca3c798747a1f254/1160a/prototype_deepcopy.jpg 373w,
/static/1e82271c3fe0608bca3c798747a1f254/aa03c/prototype_deepcopy.jpg 745w,
/static/1e82271c3fe0608bca3c798747a1f254/a1b4d/prototype_deepcopy.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>위의 예제를 보면 Circle 생성자 함수가 생성하는 모든 객체는 radius 프로퍼티와 getArea라는 메소드를 갖는다. 각 일반적으로 인스턴스마다 상태는 다 다르다. 하지만 <strong><em>동작 역할을 하는 메소드의 경우 모든 인스턴스가 동일한 내용의 메소드를 사용하므로 이는 인스턴스를 생성할때마다 중복 생성(깊은 복사)이 되어 불필요한 메모리 낭비를 할 위험성이 크다.</em></strong> 그래서 하나만 생성하여 모든 인스턴스에 공유하는 것이 좋을 것 같다.</p>
<p>상속을 통해 불필요한 중복을 제거해보자. 이럴때 자바스크립트는 프로토타입을 기반으로 상속을 구현한다</p>
<p><strong>프로토 타입을 활용한 예시</strong></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token parameter">radius</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>radius <span class="token operator">=</span> radius<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.</span>
<span class="token class-name">Circle</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getArea</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>radius<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 인스턴스 생성</span>
<span class="token keyword">const</span> circle1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> circle2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는</span>
<span class="token comment">// 프로토타입 Circle.prototype로부터 getArea 메소드를 상속받는다.</span>
<span class="token comment">// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>circle1<span class="token punctuation">.</span>getArea <span class="token operator">===</span> circle2<span class="token punctuation">.</span>getArea<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>circle1<span class="token punctuation">.</span><span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3.141592653589793</span>
<span class="token comment">// 동작원리</span>
<span class="token comment">// ① 식별자(circle1)를 스코프 체인으로 먼저 찾는다.</span>
<span class="token comment">// ② circle1의 프로토타입 체인을 찾는다.</span>
<span class="token comment">// ③ circle1에 프로퍼티로 getArea이 있는지 찾는다.</span>
<span class="token comment">// ④ circle1에 없을 시 __proto__(접근자 프로퍼티)를 통해 prototype에 접근한다. 이때 circle1.__proto__ 는 circle의 프로토타입을 참조한다.</span>
<span class="token comment">// ⑤ 참조한 후 접근자 프로퍼티의 get으로 원하는 값을 가져온다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>circle2<span class="token punctuation">.</span><span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12.566370614359172</span></code></pre></div>
<p><strong>그림으로 알아보자</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/ea010f1b1cf3417849688d5b06f99833/a1b4d/prototype_chain.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7UdClRSP/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEREgITIf/aAAgBAQABBQKvdeMjIRVH/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAGBEAAgMAAAAAAAAAAAAAAAAAAAERIUH/2gAIAQIBAT8Bl4Wf/8QAGRAAAQUAAAAAAAAAAAAAAAAAEQABIDGS/9oACAEBAAY/ArRL6j//xAAbEAEAAgIDAAAAAAAAAAAAAAABADEhQRFhsf/aAAgBAQABPyHZ6iyWV5tB7hG5iogGp//aAAwDAQACAAMAAAAQoA//xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAwEBPxCH/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/EMaQ/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARITFxkf/aAAgBAQABPxBrpNvVL2CwgF/cgVwzJAlXOHLyBUA8n//Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype chain"
        title="prototype chain"
        src="/static/ea010f1b1cf3417849688d5b06f99833/aa03c/prototype_chain.jpg"
        srcset="/static/ea010f1b1cf3417849688d5b06f99833/31ba1/prototype_chain.jpg 186w,
/static/ea010f1b1cf3417849688d5b06f99833/1160a/prototype_chain.jpg 373w,
/static/ea010f1b1cf3417849688d5b06f99833/aa03c/prototype_chain.jpg 745w,
/static/ea010f1b1cf3417849688d5b06f99833/a1b4d/prototype_chain.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 프로토타입에서 생성자 함수 참조</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>circle1<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ƒ Circle</span>

<span class="token comment">// 생성자함수에서 프로토타입 참조</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Circle</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Circle { getArea: ƒ}</span>

<span class="token comment">// Circle 생성자함수로 만든 모든 인스턴스가 Circle.prototype에 상속된다.</span>
circle1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Circle</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>
circle2<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Circle</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>
circle1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> circle2<span class="token punctuation">.</span>__proto__ <span class="token comment">// true</span></code></pre></div>
<p>Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 부모 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메소드를 상속받는다.</p>
<blockquote>
<p><b>자바스크립트엔진이 cratefunction이라는 것으로 함수 객체가 평가되어 객체가 만들어질때 prototype이라는 속성을 동적으로 생성해주고 prototype 객체를 생성해서 할당해준다.</b> 비어있는 프로토타입 객체에 프로퍼티를 할당하는 것은 개발자가 해야될 일이다.</p>
</blockquote>
<p>prototype의 메소드로 할당되면 Circle 생성자 함수가 생성하는 모든 인스턴스는 prototype에 할당된 메소드를 상속받아 사용할 수 있다. <strong>즉, 자신의 상태는 나타내는 프로퍼티만을 개별적으로 소유하고 중복되는 메소드(동작)은 상속을 통해 공유하여 사용하는 것이다.</strong></p>
<p><strong>상속은 코드의 재사용성이라는 관점에서 매우 유용하다</strong>.<br>
<b>생성자 함수가 생성할 모든 인스턴스에 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현에 놓으면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현없이 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.</b></p>
<br>
<h2 id="프로토타입-객체"><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4" aria-label="프로토타입 객체 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로토타입 객체</h2>
<p>프로토타입 객체(또는 줄여서 프로토타입)이란 객체 지향 프로그래밍의 근간을 이루는 <b>객체간 상속을 구현하기 위해 사용된다. 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 프로퍼티(메소드 포함)를 공유한다.</b> <strong>프로토타입을 상속받은 하위(자식)객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.</strong></p>
<p><strong>모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다.</strong> 모든 객체는 생성될 때 [[Prototype]] 내부 슬롯의 값으로 프로토 타입의 참조를 저장한다. 즉 <b>모든 객체는 하나의 프로토 타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정된다.</b></p>
<p>모든 객체는 하나의 프로토타입을 갖는다. 프로토타입은 null(최상위)이거나 객체이다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. 즉, 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다.</p>
<p><strong>그림으로 알아보자</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/d4d01ebedffb5bdb6f5563585ba44380/a1b4d/prototype_object.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIBAwQF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB7delSBg//8QAGRAAAgMBAAAAAAAAAAAAAAAAAhEAARAy/9oACAEBAAEFAlcNsed//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAQUBAAAAAAAAAAAAAAAAAAIREiAxIf/aAAgBAQAGPwLTi4mvT//EABoQAAIDAQEAAAAAAAAAAAAAAAERABBRIUH/2gAIAQEAAT8h6wPmsTjgG/dojtf/2gAMAwEAAgADAAAAENDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFxEBAAMAAAAAAAAAAAAAAAAAARARMf/aAAgBAgEBPxC0yP/EABwQAAICAgMAAAAAAAAAAAAAAAERACEQMVGBkf/aAAgBAQABPxDeNeFC3KgVHtcEHUWq8YCWZgCCn//Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="object prototype"
        title="object prototype"
        src="/static/d4d01ebedffb5bdb6f5563585ba44380/aa03c/prototype_object.jpg"
        srcset="/static/d4d01ebedffb5bdb6f5563585ba44380/31ba1/prototype_object.jpg 186w,
/static/d4d01ebedffb5bdb6f5563585ba44380/1160a/prototype_object.jpg 373w,
/static/d4d01ebedffb5bdb6f5563585ba44380/aa03c/prototype_object.jpg 745w,
/static/d4d01ebedffb5bdb6f5563585ba44380/a1b4d/prototype_object.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>위 그림처럼 객체는 __ proto __ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 자신의 [[Prototype]] 내부 슬롯이 가리키는 객체에 접근할 수 있다. 그리고 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있다. 생성자 함수는 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.</p>
<br>
<h3 id="__-proto-__-접근자-프로퍼티"><a href="#__-proto-__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0" aria-label="__ proto __ 접근자 프로퍼티 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>__ proto __ 접근자 프로퍼티</h3>
<p>모든 객체는 __ proto __ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다.</p>
<p><em>아래의 예제를 Chrome 브라우저의 콘솔에서 출력해보자</em></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Lee'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

person</code></pre></div>
<p><strong>출력화면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/40e6f187dc6a549e841381ca2c25f64e/a1b4d/prototype_chrome.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 53.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAv/aAAwDAQACEAMQAAAB3U4ysGU//8QAFxAAAwEAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAQABBQJmuO//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGn/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRAAAgMBAAAAAAAAAAAAAAAAABABETHw/9oACAEBAAE/IdHFLRC//9oADAMBAAIAAwAAABAXD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EFDP/8QAHBABAAEEAwAAAAAAAAAAAAAAAQAQETFBIVFx/9oACAEBAAE/EGhs66gmLBRi8hOXdP/Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype chrome"
        title="prototype chrome"
        src="/static/40e6f187dc6a549e841381ca2c25f64e/aa03c/prototype_chrome.jpg"
        srcset="/static/40e6f187dc6a549e841381ca2c25f64e/31ba1/prototype_chrome.jpg 186w,
/static/40e6f187dc6a549e841381ca2c25f64e/1160a/prototype_chrome.jpg 373w,
/static/40e6f187dc6a549e841381ca2c25f64e/aa03c/prototype_chrome.jpg 745w,
/static/40e6f187dc6a549e841381ca2c25f64e/a1b4d/prototype_chrome.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>위 그림의 빨간 박스로 표시한 것이 person 객체의 프로토타입인 Object.prototype이다. 이는 __ proto __ 접근자 프로퍼티를 통해 person 객체의 [[Prototype]] 내부 슬롯이 가리키는 객체인 Object.prototype에 접근한 결과를 크롬 브라우저가 콘솔에 표시한 것이다. 이처럼 모든 객체는 프로토타입을 가리키는 [[Prototype]] 내부 슬롯에 접근하기 위해 __ proto __ 접근자 프로퍼티를 사용할 수 있다.</p>
<br>
<h4 id="__-proto-__는-접근자-프로퍼티이다"><a href="#__-proto-__%EB%8A%94-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%9D%B4%EB%8B%A4" aria-label="__ proto __는 접근자 프로퍼티이다 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>__ proto __는 접근자 프로퍼티이다.</h4>
<p><a href="/posts/javascript/property#%EB%82%B4%EB%B6%80-%EC%8A%AC%EB%A1%AF%EB%A9%94%EC%86%8C%EB%93%9C">내부슬롯/메소드</a>에서 말햇듯 내부 슬롯은 프로퍼티가 아니다. 따라서 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다. [[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 __ proto __ 접근자 프로퍼티를 통해 간접적으로 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근할 수 있다.</p>
<p><strong>출력화면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/bbcb7d06ebf374cba1357e3b3e2a9e0a/a1b4d/prototype_proto_.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAEABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3gUD/8QAFRABAQAAAAAAAAAAAAAAAAAAARD/2gAIAQEAAQUCb//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABcQAQADAAAAAAAAAAAAAAAAAAEAEDH/2gAIAQEAAT8hzAK//9oADAMBAAIAAwAAABBwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABcQAAMBAAAAAAAAAAAAAAAAAAABERD/2gAIAQEAAT8QSmJOZ//Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype proto"
        title="prototype proto"
        src="/static/bbcb7d06ebf374cba1357e3b3e2a9e0a/aa03c/prototype_proto_.jpg"
        srcset="/static/bbcb7d06ebf374cba1357e3b3e2a9e0a/31ba1/prototype_proto_.jpg 186w,
/static/bbcb7d06ebf374cba1357e3b3e2a9e0a/1160a/prototype_proto_.jpg 373w,
/static/bbcb7d06ebf374cba1357e3b3e2a9e0a/aa03c/prototype_proto_.jpg 745w,
/static/bbcb7d06ebf374cba1357e3b3e2a9e0a/a1b4d/prototype_proto_.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Object.prototype의 프로퍼티인 __ proto __ 접근자 프로퍼티는 getter/setter 함수라고 부르는 접근자 함수를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당한다. __ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하면 내부적으로 __ proto __ 접근자 프로퍼티의 getter 함수인 get __ proto __ 가 호출된다. __ proto __ 접근자 프로퍼티를 통해 새로운 프로토타입을 할당하면 __ proto __ 접근자 프로퍼티의 setter 함수인 set __ proto __ 가 호출된다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득</span>
obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
<span class="token comment">// setter함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체</span>
obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> parent<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre></div>
<blockquote>
<p><strong>내부 메소드 [[GetPrototypeOf]]와 [[SetPrototypeOf]]</strong><br>get __ proto __은 [[GetPrototypeOf]] 내부 메소드를 호출하여 자신의 프로토타입을 취득하고,<br>set __ proto __은 [[SetPrototypeOf]] 내부 메소드를 호출하여 새로운 프로토타입을 할당한다.</p>
</blockquote>
<hr />
<h4 id="__-proto-__-접근자-프로퍼티는-상속을-통해-사용된다"><a href="#__-proto-__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%8A%94-%EC%83%81%EC%86%8D%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%82%AC%EC%9A%A9%EB%90%9C%EB%8B%A4" aria-label="__ proto __ 접근자 프로퍼티는 상속을 통해 사용된다 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>__ proto __ 접근자 프로퍼티는 상속을 통해 사용된다.</h4>
<p><b>__ proto __ 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티이다.</b> 모든 객체는 상속을 통해 Object.prototype.__ proto __ 접근자 프로퍼티를 사용할 수 있다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Lee'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// person 객체는 __proto__ 프로퍼티를 소유하지 않는다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'__proto__'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token comment">// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티이다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'__proto__'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// {get: ƒ, set: ƒ, enumerable: false, configurable: true}</span>

<span class="token comment">// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<hr />
<h4 id="__-proto-__-접근자-프로퍼티를-통해-프로토타입에-접근하는-이유"><a href="#__-proto-__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%ED%86%B5%ED%95%B4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0" aria-label="__ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>__ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유</h4>
<p>[[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 <strong><em>상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함이다.</em></strong><br></p>
<p><strong>아래 그림을 살펴보자.</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/c547a0d555d72a0a223cb67ed9583fa2/a1b4d/prototype_chain2.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 26.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAUE/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQP/2gAMAwEAAhADEAAAAbmMoUBN/8QAGRAAAQUAAAAAAAAAAAAAAAAAAAIDERIy/9oACAEBAAEFAl4ai5//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAWEQADAAAAAAAAAAAAAAAAAAACEDH/2gAIAQIBAT8BGL//xAAXEAADAQAAAAAAAAAAAAAAAAAAARAx/9oACAEBAAY/AmZP/8QAGhAAAgIDAAAAAAAAAAAAAAAAAREAIRBRcf/aAAgBAQABPyHtqGQpa2cf/9oADAMBAAIAAwAAABAED//EABYRAAMAAAAAAAAAAAAAAAAAAAEQMf/aAAgBAwEBPxA1f//EABYRAAMAAAAAAAAAAAAAAAAAAAEQIf/aAAgBAgEBPxALX//EABoQAQEAAgMAAAAAAAAAAAAAAAERABAhkbH/2gAIAQEAAT8QQMkXSy9YZm75G9df/9k='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype chian"
        title="prototype chian"
        src="/static/c547a0d555d72a0a223cb67ed9583fa2/aa03c/prototype_chain2.jpg"
        srcset="/static/c547a0d555d72a0a223cb67ed9583fa2/31ba1/prototype_chain2.jpg 186w,
/static/c547a0d555d72a0a223cb67ed9583fa2/1160a/prototype_chain2.jpg 373w,
/static/c547a0d555d72a0a223cb67ed9583fa2/aa03c/prototype_chain2.jpg 745w,
/static/c547a0d555d72a0a223cb67ed9583fa2/a1b4d/prototype_chain2.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// child의 프로토타입을 parent로 지정</span>
child<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> parent<span class="token punctuation">;</span>
<span class="token comment">// parent의 프로토타입을 child로 설정</span>
parent<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> child<span class="token punctuation">;</span> <span class="token comment">// TypeError: Cyclic __proto__ value</span></code></pre></div>
<p>위처럼 __ proto __는 상호 참조를 하게되면 무한루프에 빠질 위험성이 있어 에러메시지를 뿜는다.<br>
<b>프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 즉, 프로퍼티 검색 방향이 한쪽 방향으로만 흘러가야 한다.</b> 하지만 위 그림과 같이 <strong>순환 참조(circular reference)적인 프로토타입 체인이 만들어지면 프로토타입 체인 종점이 존재하지 않기 때문에 프로토타입 체인에서 프로퍼티를 검색할 때 무한 루프에 빠진다.</strong> 따라서 아무런 체크없이 무조건적으로 프로토타입을 교체할 수 없도록 __ proto __ 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어 있다.</p>
<hr />
<h4 id="__-proto-__-접근자-프로퍼티를-코드-내에서-직접-사용하는-것은-비추천이다"><a href="#__-proto-__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EC%BD%94%EB%93%9C-%EB%82%B4%EC%97%90%EC%84%9C-%EC%A7%81%EC%A0%91-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%B9%84%EC%B6%94%EC%B2%9C%EC%9D%B4%EB%8B%A4" aria-label="__ proto __ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천이다 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>__ proto __ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천이다.</h4>
<p>__ proto __ 접근자 프로퍼티는 ES5까지 ECMAScript 사양에 포함되지 않은 비표준이었다. 하지만 일부 브라우저에서 __ proto __를 지원하고 있었기 때문에 ES6에서 브라우저 호환성을 고려하여 __ proto __를 표준으로 채택하였다. 현재 대부분의 브라우저(IE 11 이상)가 __ proto __를 지원하고 있다.</p>
<p>하지만 코드 내에서 __ proto __를 직접 사용하는 것은 추천하지 않는다. 모든 객체가 __ proto __접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문이다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// obj는 프로토타입 체인의 종점이다. 따라서 Object.__proto__를 상속받을 수 없다.</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// obj는 Object.__proto__를 상속받을 수 없다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
<span class="token comment">// 따라서 Object.getPrototypeOf 메소드를 사용하는 편이 좋다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span></code></pre></div>
<p>__ proto __ 접근자 프로퍼티 대신 프로토타입의 참조를 취득할 경우는 Object.getPrototypeOf 메소드를, 프로토타입을 교체하는 경우는 Object.setPrototypeOf 메소드를 사용하는 것을 권장한다.</p>
<blockquote>
<p><b>Object.getPrototypeOf(인수= 객체)</b><br>
Object.getPrototypeOf 메소드는 ES5에서 도입된 메소드이며 IE9 이상을 지원한다. Object.setPrototypeOf 메소드는 ES6에서 도입된 메소드이며 IE11 이상을 지원한다.</p>
</blockquote>
<hr class="sub" />
<h3 id="함수-객체의-prototype-프로퍼티"><a href="#%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EC%9D%98-prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0" aria-label="함수 객체의 prototype 프로퍼티 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>함수 객체의 prototype 프로퍼티</h3>
<p>함수 객체는 __ proto __ 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. <b>함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</b></p>
<p><em>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.</em></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 함수 객체는 prototype 프로퍼티를 소유한다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'prototype'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'prototype'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre></div>
<p>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로서 사용될 때, 생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킨다. 따라서 생성자 함수로서 호출할 수 없는 함수<a href="/posts/javascript/constructor/#%EB%82%B4%EB%B6%80-%EB%A9%94%EC%86%8C%EB%93%9C-call%EA%B3%BC-construct">(참고)</a>, <em>즉 함수의 종류가 Arrow, Method인 함수인 non-constructor는 프로토타입이 생성되지 않으며 prototype 프로퍼티도 소유하지 않는다.</em></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 화살표 함수는 non-constructor이다.</span>
<span class="token keyword">const</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token parameter">name</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// non-constructor는 프로토타입이 생성되지 않는다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>

<span class="token comment">// non-constructor는 prototype 프로퍼티도 소유하지 않는다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'prototype'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token comment">// ES6의 메소드 축약 표현으로 정의한 메소드는 non-constructor이다.</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// non-constructor는 프로토타입이 생성되지 않는다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>

<span class="token comment">// non-constructor는 prototype 프로퍼티도 소유하지 않는다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'prototype'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre></div>
<p>생성자 함수가 아닌 일반 함수도 prototype 프로퍼티를 소유하지만 객체를 생성하지 않는 일반 함수의 prototype 프로퍼티는 아무런 의미가 없다.</p>
<br>
<p>모든 객체가 가지고 있는(엄밀히 말하면 Object.prototype으로부터 상속받은) __ proto __ 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다. 하지만 이들 프로퍼티를 사용하는 주체가 다르다.</p>
<article class="board-tbl">
<table>
<thead>
<tr>
<th align="center">구분</th>
<th align="center">소유</th>
<th align="center">값</th>
<th align="center">사용주체</th>
<th align="left">사용목적</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">__ proto __ 접근자 프로퍼티</td>
<td align="center">모든 객체</td>
<td align="center">프로토타입의 참조</td>
<td align="center">모든 객체</td>
<td align="left">모든 객체가 상속을 위해 자신의 프로토타입에 접근하기 위해 사용</td>
</tr>
<tr>
<td align="center">prototype 프로퍼티</td>
<td align="center">함수 객체</td>
<td align="center">프로토타입의 참조</td>
<td align="center">생성자 함수</td>
<td align="left">생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용</td>
</tr>
</tbody>
</table>
</article>
<br>
<p>예를 들어 생성자 함수로 객체를 생성한 후 __ proto __ 접근자 프로퍼티와 prototype 프로퍼티로 프로토타입 객체에 접근해보자.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Person.prototype: Person 생성자 함수는 prototype 프로퍼티를 통해</span>
<span class="token comment">// 자신이 생성할 인스턴스(이 경우에는 me)의 프로토타입을 할당</span>
<span class="token comment">// me.__proto__: 객체 me의 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입에 접근</span>
<span class="token comment">// 결국 Person.prototype와 me.__proto__는 결국 동일한 프로토타입을 가리킨다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> me<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span></code></pre></div>
<br>
<p><strong>위 예제를 그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/8891c03cc6c86df39b157672d3c4ad3f/a1b4d/prototype_chain3.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIDBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHajsKA4f/EABoQAAICAwAAAAAAAAAAAAAAAAECAxAREiH/2gAIAQEAAQUC17IgJUYW/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAWEQADAAAAAAAAAAAAAAAAAAAQIUH/2gAIAQIBAT8BcH//xAAYEAEBAAMAAAAAAAAAAAAAAAABACAhkf/aAAgBAQAGPwK2vYMP/8QAGhABAAIDAQAAAAAAAAAAAAAAAQARIUFRkf/aAAgBAQABPyG3Xss4mtIhCNh1uLTHMME//9oADAMBAAIAAwAAABBDD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABkRAAEFAAAAAAAAAAAAAAAAAAABESExQf/aAAgBAgEBPxB0WJ0//8QAHBABAAICAwEAAAAAAAAAAAAAAQARITFRYYGR/9oACAEBAAE/EMBHe4D1gAE+EbEChRPrEw8TNenqCgn/2Q=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype chian"
        title="prototype chian"
        src="/static/8891c03cc6c86df39b157672d3c4ad3f/aa03c/prototype_chain3.jpg"
        srcset="/static/8891c03cc6c86df39b157672d3c4ad3f/31ba1/prototype_chain3.jpg 186w,
/static/8891c03cc6c86df39b157672d3c4ad3f/1160a/prototype_chain3.jpg 373w,
/static/8891c03cc6c86df39b157672d3c4ad3f/aa03c/prototype_chain3.jpg 745w,
/static/8891c03cc6c86df39b157672d3c4ad3f/a1b4d/prototype_chain3.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span>
이런식의 그림이 나온다.</p>
<hr class="sub" />
<h3 id="프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-constructor-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98" aria-label="프로토타입의 constructor 프로퍼티와 생성자 함수 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로토타입의 constructor 프로퍼티와 생성자 함수</h3>
<p>모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 생성자 함수가 생성될 때,
<b>즉 함수 객체가 생성될 때 이루어진다.</b></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// me 객체의 생성자 함수는 Person이다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span></code></pre></div>
<p>위 예제에서 Person 생성자 함수는 me 객체를 생성했다. 이때 me 객체는 프로토타입의 contructor 프로퍼티를 통해 생성자 함수와 연결된다. me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로토타입인 Person.prototype에 constructor 프로퍼티가 있다. me 객체는 프로토타입인 Person.prototype에 constructor 프로퍼티를 상속받아 사용할 수 있다.</p>
<br>
<h2 id="리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%91%9C%EA%B8%B0%EB%B2%95%EC%97%90-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85" aria-label="리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h2>
<p>생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다. 이때 생성자 함수는 인스턴스를 생성한 생성자 함수이다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// obj 객체를 생성한 생성자 함수는 Object이다.</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// add 함수 객체를 생성한 생성자 함수는 Function이다.</span>
<span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'return a + b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// me 객체를 생성한 생성자 함수는 Person이다.</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>하지만 리터럴 표기법에 의한 객체 생성 방식과 같이 new 연산자 없이 객체를 생성하는 방식도 존재한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 객체 리터럴</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 함수 리터럴</span>
<span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 배열 리터럴</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 정규표현식 리터럴</span>
<span class="token keyword">const</span> regexr <span class="token operator">=</span> <span class="token regex">/is/ig</span><span class="token punctuation">;</span></code></pre></div>
<p>리터럴 표기법에 의해 생성된 객체도 물론 프로토타입이 존재한다. 하지만 리터럴 표기법에 의해 생성된 객체의 경우, 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 객체 obj는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성하였다.</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 하지만 객체 obj의 생성자 함수는 Object 생성자 함수이다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p><strong>Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다.</strong> 그리고 인수가 전달되지 않았을 때 추상 연산 ObjectCreate을 호출하여 빈 객체를 생성한다. 인수가 전달된 경우에는 인수를 객체로 변환한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Object 생성자 함수에 의한 객체 생성</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {}</span>

<span class="token comment">// Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다.</span>
<span class="token comment">// 인수가 전달되지 않았을 때 추상 연산 ObjectCreate을 호출하여 빈 객체를 생성한다.</span>
obj <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {}</span>

<span class="token comment">// 인수가 전달된 경우에는 인수를 객체로 변환한다.</span>
<span class="token comment">// Number 객체 생성</span>
obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Number {123}</span>

<span class="token comment">// String  객체 생성</span>
obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// String {"123"}</span></code></pre></div>
<p>객체 리터럴이 평가될 때는 추상 연산 ObjectCreate을 호출하여 빈객체를 생성하고 프로퍼티를 추가하도록 정의되어 있다.</p>
<p>이처럼 Object 생성자 함수와 객체 리터럴의 평가는 추상 연산 ObjectCreate을 호출하여 빈 객체를 생성하는 것은 동일하나 <b>new.target 확인이나 프로퍼티를 추가하는 처리 등 세부 내용은 다르다.</b> 따라서 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.</p>
<p>함수 객체의 경우, 더욱 차이가 명확하다. <a href="/posts/javascript/Function/#function-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98function-constructor">Function 생성자함수</a>에서 살펴보았듯이 Function 생성자 함수 방식으로 생성한 함수는 렉시컬 스코프를 만들지 않고 전역 함수인 것처럼 스코프를 생성하며 클로저도 만들지 않는다. 따라서 함수 선언문과 함수 표현식을 평가하여 함수 객체를 생성한 것은 Function 생성자 함수가 아니다. 하지만 함수 foo의 생성자 함수는 Function 생성자 함수이다.</p>
<br>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 함수 객체 foo는 Function 생성자 함수로 생성한 함수 객체가 아니라 함수 선언문으로 생성하였다.</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 하지만 함수 객체 foo의 생성자 함수는 Function 생성자 함수이다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p>리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하다. 따라서 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖는다. 프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼터에 의해 연결되어 있기 때문이다. 다시 말해, 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍(pair)으로 존재하기 때문이다.</p>
<p>리터럴 표기법(객체 리터럴, 함수 리터럴, 배열 리터럴, 정규 표현식 리터럴 등)에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니다. 하지만 큰 틀에서 생각해 보면 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서 큰 차이는 없다.</p>
<p>예를 들어, 객체 리터럴에 의해 생성한 객체와 Object 생성자 함수에 의해 생성한 객체는 생성 과정에 차이는 있지만 결국 객체로서 동일한 특성을 갖는다. 함수 리터럴에 의해 생성한 함수와 Function 생성자 함수에 의해 생성한 함수는 생성 과정과 스코프, 클로저 등의 차이가 있지만 결국 함수로서 동일한 특성을 갖는다.</p>
<p>따라서 프로토타입의 constructor 프로퍼티로 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 크게 무리는 없다. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입은 아래와 같다.</p>
<article class="board-tbl">
<table>
<thead>
<tr>
<th align="left">리터럴 표기법</th>
<th align="left">생성자 함수</th>
<th align="left">프로토타입</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">객체 리터럴</td>
<td align="left">Object</td>
<td align="left">Object.protptype</td>
</tr>
<tr>
<td align="left">함수 리터럴</td>
<td align="left">Function</td>
<td align="left">Function.prototype</td>
</tr>
<tr>
<td align="left">배열 리터럴</td>
<td align="left">Array</td>
<td align="left">Array.prototype</td>
</tr>
<tr>
<td align="left">정규 표현식 리터럴</td>
<td align="left">RegExp</td>
<td align="left">RegExp.protptype</td>
</tr>
</tbody>
</table>
</article>
<br>
<h2 id="프로토타입의-생성-시점"><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EC%83%9D%EC%84%B1-%EC%8B%9C%EC%A0%90" aria-label="프로토타입의 생성 시점 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로토타입의 생성 시점</h2>
<h3 id="사용자-정의-생성자-함수와-프로토타입-생성시점"><a href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%83%9D%EC%84%B1%EC%8B%9C%EC%A0%90" aria-label="사용자 정의 생성자 함수와 프로토타입 생성시점 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용자 정의 생성자 함수와 프로토타입 생성시점</h3>
<p>내부메소드 [[Construct]]를 갖는 함수 객체, 즉 화살표 함수나 ES6의 메소드 축약표현으로 정의하지 않고 일반함수(함수 선언문, 함수 표현식)로 정의한 함수 객체는 new 연산자와 함께 생성자 함수로서 호출할 수 있다.</p>
<p>생성자 함수로서 호출할 수 있는 함수, 즉 <b>constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.</b></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {constructor: ƒ}</span>

<span class="token comment">// 생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span></code></pre></div>
<p>함수 선언문은 함수 호이스팅으로 인해 다른 코드가 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 따라서 함수 선언문으로 정의된 Person 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 된다. 이때 프로토타입도 더불어 생성된다. 생성된 프로토타입은 Person 생성자 함수의 prototype 프로퍼티에 바인딩된다.</p>
<p>Person 생성자 함수와 더불어 생성된 프로토타입 내부를 살펴보자</p>
<p><strong>위 예제를 그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/fd1152c6d8defac98e57361b0a62fe66/a1b4d/prototype_constructor.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 26.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd6AuD//xAAWEAEBAQAAAAAAAAAAAAAAAAABABD/2gAIAQEAAQUCYz//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAVEAEBAAAAAAAAAAAAAAAAAAAQMf/aAAgBAQABPyGH/9oADAMBAAIAAwAAABCED//EABURAQEAAAAAAAAAAAAAAAAAABBB/9oACAEDAQE/EIf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAYEAEAAwEAAAAAAAAAAAAAAAABABARIf/aAAgBAQABPxB45lHhX//Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype constructor"
        title="prototype constructor"
        src="/static/fd1152c6d8defac98e57361b0a62fe66/aa03c/prototype_constructor.jpg"
        srcset="/static/fd1152c6d8defac98e57361b0a62fe66/31ba1/prototype_constructor.jpg 186w,
/static/fd1152c6d8defac98e57361b0a62fe66/1160a/prototype_constructor.jpg 373w,
/static/fd1152c6d8defac98e57361b0a62fe66/aa03c/prototype_constructor.jpg 745w,
/static/fd1152c6d8defac98e57361b0a62fe66/a1b4d/prototype_constructor.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>생성된 프로토타입은 constructor 프로퍼티만을 갖는 객체이다. <b>프로토타입도 객체이고 모든 객체는 프로토타입을 갖기 때문에 프로토타입도 자신의 프로토타입을 갖는다. 생성된 프로토타입의 프로토타입은 Object.prototype이다.</b></p>
<p><strong>위 예제를 그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/3cc5d1792a90321766e5442099371b8f/a1b4d/prototype_object_proto_.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 73.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgb/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHQKKDSA//EABkQAAMBAQEAAAAAAAAAAAAAAAACEQESMf/aAAgBAQABBQIbKL5dH16l5//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABEQ/9oACAECAQE/ARn/xAAaEAACAgMAAAAAAAAAAAAAAAAAAQIiESCB/9oACAEBAAY/AtKxT6WWGf/EABsQAAMBAAMBAAAAAAAAAAAAAAABESExUWFx/9oACAEBAAE/IRTaJMDvwp9IEj2BnwdCdP/aAAwDAQACAAMAAAAQNw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAXEQADAQAAAAAAAAAAAAAAAAAAESEB/9oACAECAQE/EEjRKH//xAAbEAEAAgIDAAAAAAAAAAAAAAABABFRkSExQf/aAAgBAQABPxCAcDLAE6EAwqewQExy3B1ADYG6Dc//2Q=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype"
        title="prototype"
        src="/static/3cc5d1792a90321766e5442099371b8f/aa03c/prototype_object_proto_.jpg"
        srcset="/static/3cc5d1792a90321766e5442099371b8f/31ba1/prototype_object_proto_.jpg 186w,
/static/3cc5d1792a90321766e5442099371b8f/1160a/prototype_object_proto_.jpg 373w,
/static/3cc5d1792a90321766e5442099371b8f/aa03c/prototype_object_proto_.jpg 745w,
/static/3cc5d1792a90321766e5442099371b8f/a1b4d/prototype_object_proto_.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>이처럼 <strong>빌트인 생성자 함수가 아닌 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며 생성된 프로토타입의 프로토타입은 언제나 Object.prototype이다.</strong></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 화살표 함수는 non-constructor이다.</span>
<span class="token keyword">const</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token parameter">name</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// non-constructor는 프로토타입이 생성되지 않는다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></code></pre></div>
<p>생성자 함수로서 호출할 수 없는, 즉 non-constructor는 프로토타입이 생성되지 않는다.</p>
<hr class="sub" />
<h3 id="빌트인-생성자-함수와-프로토타입-생성시점"><a href="#%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%83%9D%EC%84%B1%EC%8B%9C%EC%A0%90" aria-label="빌트인 생성자 함수와 프로토타입 생성시점 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>빌트인 생성자 함수와 프로토타입 생성시점</h3>
<p><strong>Object, String, Number, Function, Array, RegExp, Date, Promise 등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다.</strong> 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다.</p>
<p>전역 객체는 누구보다도 먼저 생성된다. 이때 빌트인 생성자 함수와 더불어 프로토타입이 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다.</p>
<p><strong>그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/4ea9e3d3bd3ad4cdbca8ba140b276f30/a1b4d/prototype_object2.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxLzAYP/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAECETH/2gAIAQEAAQUCpkk7jgxZ/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAECIREgMf/aAAgBAQAGPwLpUmi3nT//xAAaEAEAAgMBAAAAAAAAAAAAAAABABARIVEx/9oACAEBAAE/Id8v1TgEKYoute6v/9oADAMBAAIAAwAAABAbD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAgEBPxAcn//EABwQAQACAgMBAAAAAAAAAAAAAAEAIRGREDFhcf/aAAgBAQABPxAsKfMEDJIDKH2yDslNALquAazon//Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype object"
        title="prototype object"
        src="/static/4ea9e3d3bd3ad4cdbca8ba140b276f30/aa03c/prototype_object2.jpg"
        srcset="/static/4ea9e3d3bd3ad4cdbca8ba140b276f30/31ba1/prototype_object2.jpg 186w,
/static/4ea9e3d3bd3ad4cdbca8ba140b276f30/1160a/prototype_object2.jpg 373w,
/static/4ea9e3d3bd3ad4cdbca8ba140b276f30/aa03c/prototype_object2.jpg 745w,
/static/4ea9e3d3bd3ad4cdbca8ba140b276f30/a1b4d/prototype_object2.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<blockquote>
<p><strong>전역 객체(Global object)</strong><br>
전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체이다. 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다. 전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array…)들과 환경에 따른 호스트 객체(클라이언트 web API 또는 Node.js의 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. Math를 제외한 표준 빌트인 객체는 모두 생성자 함수이다.</p>
</blockquote>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 전역 객체 window는 브라우저에 종속적이므로 아래 코드는 브라우저 환경에서 실행해야 한다.</span>
<span class="token comment">// 빌트인 객체인 Object는 전역 객체 window의 프로퍼티이다.</span>
window<span class="token punctuation">.</span>Object <span class="token operator">===</span> Object <span class="token comment">// true</span></code></pre></div>
<p>전역 객체는 누구보다도 먼저 생성된다. 표준 빌트인 객체인 Object도 전역 객체의 프로퍼티이며 전역 객체가 생성되는 시점에 같이 생성된다. 정확히 말하자면 <em>전역 객체는 다른 빌트인 객체를 포함하는 객체이므로 다른 빌트인 객체가 생성되기 이전에 먼저 생성되어야 한다. 전역 객체가 생성된 이후, 빌트인 객체가 생성되어 프로퍼티로 추가된다.</em></p>
<hr class="sub" />
<h3 id="객체-생성-방식과-프로토타입의-결정"><a href="#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B2%B0%EC%A0%95" aria-label="객체 생성 방식과 프로토타입의 결정 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>객체 생성 방식과 프로토타입의 결정</h3>
<p>객체는 여러가지 다양한 생성 방법이 있다.</p>
<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메소드</li>
<li>클래스(ES6)</li>
</ul>
<p><em>모든 객체는 각각의 방식마다 세부적인 객체 생성방식의 차이는 있으나 추상 연산 <strong>ObjectCreate</strong>에 의해 생성된다는 공통점을 갖는다</em></p>
<p>런타임에 새로운 객체를 생성하는 추상 연산 ObjectCreate는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달 받는다. 그리고 자신이 생성할 객체에 추가할 프로퍼티 목록은 옵션으로 전달할 수 있다.</p>
<p>추상 연산 ObjectCreate는 빈객체를 생성한 후, 객체에 추가할 프로퍼티 목록(internalSlotList)이 인수로 전달된 경우, 프로퍼티를 객체에 추가한다. 그리고 인수로 전달받은 프로토타입을 자신이 생성한 객체의 [[Prototype]] 내부 슬롯에 할당한 다음, 생성한 객체를 반환한다.</p>
<p>즉, 프로토타입은 추상 연산 ObjectCreate에 전달되는 인수에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.</p>
<br>
<h4 id="객체-리터럴에-의해-생성된-객체의-프로토타입"><a href="#%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%97%90-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85" aria-label="객체 리터럴에 의해 생성된 객체의 프로토타입 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>객체 리터럴에 의해 생성된 객체의 프로토타입</h4>
<p><em>자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할때, 추상연산 ObjectCreate를 호출한다.</em></p>
<p>이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>위 객체 리터럴이 평가되면 Object.Create에 의해 Object 생성자 함수와 Object.prototype에 생성된 객체의 연결이 만들어 진다</p>
<p><strong>그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/3d5008d2819be6862b447fd2eb56aa84/a1b4d/prototype_object3.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 73.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxLzAYP/8QAGRABAAIDAAAAAAAAAAAAAAAAAQACESEx/9oACAEBAAEFAsMuK10S0Of/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAREP/aAAgBAgEBPwFJ/8QAGxAAAgEFAAAAAAAAAAAAAAAAAAEhAhEgMXH/2gAIAQEABj8C2RU1wl3w/8QAHBABAAIBBQAAAAAAAAAAAAAAAQARURAhMZGh/9oACAEBAAE/IW7nBHQoWlFl0tex7M0//9oADAMBAAIAAwAAABBDD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABcRAAMBAAAAAAAAAAAAAAAAAAARIUH/2gAIAQIBAT8Q0G6f/8QAHhABAQACAQUBAAAAAAAAAAAAAREAIUEQMXGRodH/2gAIAQEAAT8QS0A4IfmJAwbBt7HDFKezfmumlJ1zGXER83P/2Q=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype object"
        title="prototype object"
        src="/static/3d5008d2819be6862b447fd2eb56aa84/aa03c/prototype_object3.jpg"
        srcset="/static/3d5008d2819be6862b447fd2eb56aa84/31ba1/prototype_object3.jpg 186w,
/static/3d5008d2819be6862b447fd2eb56aa84/1160a/prototype_object3.jpg 373w,
/static/3d5008d2819be6862b447fd2eb56aa84/aa03c/prototype_object3.jpg 745w,
/static/3d5008d2819be6862b447fd2eb56aa84/a1b4d/prototype_object3.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>이처럼 객체 obj는 Object.prototype을 프로토타입으로 갖게 되며 이로써 Object.prototype을 상속받는다. <em>obj 객체는 constructor 프로퍼티와 hasOwnProperty 메소드 등을 소유하지 않지만 자신의 프로토타입인 Object.prototype의 constructor 프로퍼티와 hasOwnProperty 메소드를 자신의 자산인 것처럼 자유롭게 사용할 수 있다. 이는 obj 객체가 자신의 프로토타입인 Object.prototype 객체를 상속받았기 때문이다.</em></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 객체 obj는 Object.prototype을 상속받는다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// true</span></code></pre></div>
<hr />
<h4 id="object-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#object-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85" aria-label="object 생성자 함수에 의해 생성된 객체의 프로토타입 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object 생성자 함수에 의해 생성된 객체의 프로토타입</h4>
<p>명시적으로 Object 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 추상 연산 ObjectCreate를 호출한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre></div>
<p>위 코드가 실행되면 추상 연산 ObjectCreate에 의해 아래와 같이 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어 진다. 객체 리터럴에 의해 생성된 객체와 동일한 구조를 갖는다.</p>
<p><strong>그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/da53717f07cae36837c4d7590e2d5db5/a1b4d/prototype_object4.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 73.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHtraZowf/EABkQAQADAQEAAAAAAAAAAAAAAAEAAhEhMf/aAAgBAQABBQLHbiteEtDz/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAERD/2gAIAQIBAT8BSf/EABsQAAIBBQAAAAAAAAAAAAAAAAABIQIRIDFx/9oACAEBAAY/AtkVNcJd8P/EABwQAQACAQUAAAAAAAAAAAAAAAEAEVEQIUGRof/aAAgBAQABPyF5GCOhQtKLLpa9j2Zp/9oADAMBAAIAAwAAABDTD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABcRAAMBAAAAAAAAAAAAAAAAAAARIUH/2gAIAQIBAT8Q0G6f/8QAHRABAQACAQUAAAAAAAAAAAAAAREAITFBcZGhsf/aAAgBAQABPxBaQB4IT5iQMGwbeRwxSnhvrWNpC5URddYy4iPe5//Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype object"
        title="prototype object"
        src="/static/da53717f07cae36837c4d7590e2d5db5/aa03c/prototype_object4.jpg"
        srcset="/static/da53717f07cae36837c4d7590e2d5db5/31ba1/prototype_object4.jpg 186w,
/static/da53717f07cae36837c4d7590e2d5db5/1160a/prototype_object4.jpg 373w,
/static/da53717f07cae36837c4d7590e2d5db5/aa03c/prototype_object4.jpg 745w,
/static/da53717f07cae36837c4d7590e2d5db5/a1b4d/prototype_object4.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>위 그림처럼 obj는 Object.prototype을 프로토타입으로 갖게 되며 이로써 Object.prototype을 상속받는다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 객체 obj는 Object.prototype을 상속받는다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p>객체 리터럴과 Object 생성자 함수에 의한 객체 생성 차이는 프로퍼티를 추가하는 방식에 있다.</p>
<p>객체 리터럴 방식은 생성할때 객체 리터럴 내부에 프로퍼티를 추가, 물론 생성한 이후에도 추가적으로 추가가 가능하다.</p>
<p>Object 생성자 함수 방식은 일단 빈 객체를 생성한 이후 프로퍼티를 추가해야한다.</p>
<hr />
<h4 id="사용자정의-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%A0%95%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85" aria-label="사용자정의 생성자 함수에 의해 생성된 객체의 프로토타입 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용자정의 생성자 함수에 의해 생성된 객체의 프로토타입</h4>
<p>new 연산자와 함께 생성자 함수를 호출하여 <strong>인스턴스</strong>를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다.</p>
<p>이때 추상 연산 ObjecCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 즉, 생성자 함수에 의해 생성되는 인스턴스(객체)의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>위 코드가 실행되면 추상 연산 ObjectCreate에 의해 아래와 같이 생성자 함수와 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체와 생성된 인스턴스(객체) 사이에 연결이 만들어 진다.</p>
<p><strong>그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/d73d29482510dd035e11834ed162afe4/a1b4d/prototype_object5.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHtraYxof/EABgQAQADAQAAAAAAAAAAAAAAAAEAAhEx/9oACAEBAAEFAsZYdryIQ5//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAADAQEAAAAAAAAAAAAAAAAAEDERMv/aAAgBAQAGPwKneF1Rf//EABkQAQADAQEAAAAAAAAAAAAAAAEAESFREP/aAAgBAQABPyHWXWEeFQpu/vjnQw1if//aAAwDAQACAAMAAAAQsA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAYEQACAwAAAAAAAAAAAAAAAAAAARExcf/aAAgBAgEBPxCWqNP/xAAbEAEAAwADAQAAAAAAAAAAAAABABEhUWGBkf/aAAgBAQABPxA2qeqIVpqqtd6QWNyQF+ZEFuF/YLgAADgn/9k='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype object"
        title="prototype object"
        src="/static/d73d29482510dd035e11834ed162afe4/aa03c/prototype_object5.jpg"
        srcset="/static/d73d29482510dd035e11834ed162afe4/31ba1/prototype_object5.jpg 186w,
/static/d73d29482510dd035e11834ed162afe4/1160a/prototype_object5.jpg 373w,
/static/d73d29482510dd035e11834ed162afe4/aa03c/prototype_object5.jpg 745w,
/static/d73d29482510dd035e11834ed162afe4/a1b4d/prototype_object5.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>특이한 점은 빌트인 객체인 Object 생성자 함수와 더불어 생성된 프로토타입 Object.prototype은 다양한 빌트인 메소드(예를들어 hasOwnProperty, propertyIsEnumerable 등)을 갖고 있지만, <b>사용자 정의 생성자 함수 Person과 더불어 생성된 프로토타입 Person.prototype의 프로퍼티는 constructor 뿐이다.</b></p>
<p>Person.prototype에 프로퍼티를 추가하여 하위(자식) 객체(인스턴스)가 상속 받을 수 있도록 구현해보겠다.<br>
<em>프로토타입은 객체이다. 따라서 일반 객체와 같이 프로토타입에도 프로퍼티를 추가/삭제할 수 있다. 그리고 이렇게 추가/삭제된 프로퍼티는 프로토타입 체인에 즉각 방영된다.</em></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> you <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Kim'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

me<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! My name is Lee</span>
you<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! My name is Kim</span></code></pre></div>
<p>이렇게 되면 Person 생성자 함수를 통해 생성된 모든 객체(인스턴스)는 Person의 prototype 속성에 바인딩 되어있는 Person.prototype에 추가된 sayHello 메소드를 상속받아 자신의 메소드처럼 사용할 수 있다.</p>
<p><strong>그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/5be96895f915fbbe469e8c5bba5bf481/a1b4d/prototype_object6.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGQAAAQUAAAAAAAAAAAAAAAAAAAECAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAduOwyAUP//EABkQAAMAAwAAAAAAAAAAAAAAAAACEQEhMf/aAAgBAQABBQLY1q8Jgh//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQcf/aAAgBAgEBPwGH/8QAGxAAAQQDAAAAAAAAAAAAAAAAAAECESEgMYH/2gAIAQEABj8C2U+OFrOH/8QAGxAAAgMAAwAAAAAAAAAAAAAAAREAIVEQMaH/2gAIAQEAAT8hAe/EfVDEMNCkt4LuoAyf/9oADAMBAAIAAwAAABD8D//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABcRAQEBAQAAAAAAAAAAAAAAAAEAIUH/2gAIAQIBAT8QVJvb/8QAHBABAAMAAgMAAAAAAAAAAAAAAQARITFBUXGB/9oACAEBAAE/ENcU8UmiSK7j2yhC+SBfwlC3UQswJgJ//9k='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype object"
        title="prototype object"
        src="/static/5be96895f915fbbe469e8c5bba5bf481/aa03c/prototype_object6.jpg"
        srcset="/static/5be96895f915fbbe469e8c5bba5bf481/31ba1/prototype_object6.jpg 186w,
/static/5be96895f915fbbe469e8c5bba5bf481/1160a/prototype_object6.jpg 373w,
/static/5be96895f915fbbe469e8c5bba5bf481/aa03c/prototype_object6.jpg 745w,
/static/5be96895f915fbbe469e8c5bba5bf481/a1b4d/prototype_object6.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<br>
<h2 id="프로토타입-체인"><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8" aria-label="프로토타입 체인 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로토타입 체인</h2>
<p>변수나 함수에 스코프체인이 있듯이 프로토타입에도 체인이 존재한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 프로토타입 메소드</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// hasOwnProperty는 Object.prototype의 메소드이다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p>Person 생성자 함수에 의해 생성된 me라는 객체는 Object.prototype의 메소드인 hasOwnProperty를 호출할 수 있다. 이것은 me라는 객체가 Person.prototype뿐만 아니라 Object.prototype도 상속받았다는 의미다.</p>
<p><em>코드로 확인해보자.</em></p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p>me 객체(인스턴스)의 프로토타입은 Person.prototype이다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p>Person.prototype의 프로토타입은 Object.prototype이다. 프로토타입의 프토로타입은 언제나 Object.prototype이다.</p>
<p><strong>그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/a76a97e9309c8d9dbe3019aad9edf0e0/a1b4d/prototype_object7.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 113.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7UXyN0C2ZLcJ/8QAGhAAAgMBAQAAAAAAAAAAAAAAAREAAjESE//aAAgBAQABBQK2lwYW7ejq+YXBn//EABURAQEAAAAAAAAAAAAAAAAAABAB/9oACAEDAQE/ASH/xAAVEQEBAAAAAAAAAAAAAAAAAAAQAf/aAAgBAgEBPwEp/8QAHBAAAQMFAAAAAAAAAAAAAAAAMQABEBIgISKB/9oACAEBAAY/Ai6LzrT1ZNn/xAAcEAABBAMBAAAAAAAAAAAAAAABABEhMRBRcUH/2gAIAQEAAT8hAuYHE4aI3i8wCOgzpRI7NWJrjiqdf//aAAwDAQACAAMAAAAQCAgD/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQETH/2gAIAQMBAT8QhLY9P//EABcRAQEBAQAAAAAAAAAAAAAAAAEAERD/2gAIAQIBAT8QDeDSL//EABwQAQADAAMBAQAAAAAAAAAAAAEAESExUWFBgf/aAAgBAQABPxBLCZihBQAccpetqvbzLKVe25SmOXyX+RNSfbry4jlTfRMP1LbLe5//2Q=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype object"
        title="prototype object"
        src="/static/a76a97e9309c8d9dbe3019aad9edf0e0/aa03c/prototype_object7.jpg"
        srcset="/static/a76a97e9309c8d9dbe3019aad9edf0e0/31ba1/prototype_object7.jpg 186w,
/static/a76a97e9309c8d9dbe3019aad9edf0e0/1160a/prototype_object7.jpg 373w,
/static/a76a97e9309c8d9dbe3019aad9edf0e0/aa03c/prototype_object7.jpg 745w,
/static/a76a97e9309c8d9dbe3019aad9edf0e0/a1b4d/prototype_object7.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 __ proto __ 접근자 프로퍼티가 가리키는 링크에 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이것을 프로토타입 체인이라 한다. 프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// hasOwnProperty는 Object.prototype의 메소드이다.</span>
<span class="token comment">// me 객체는 프로토타입 체인을 따라 hasOwnProperty 메소드를 검색하여 사용한다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p>위의 코드의 과정을 풀어보면</p>
<ol>
<li>먼저 hasOwnProperty 메소드를 호출한 me 객체에서 hasOwnProperty 메소드를 검색한다. me 객체에는 hasOwnProperty 메소드가 없으므로 프로토타입 체인을 따라, 다시 말해 __ proto __ 접근자 프로퍼티에 바인딩되어 있는 프로토타입(위 예제의 경우, Person.prototype)으로 이동하여 hasOwnProperty 메소드를 검색한다.</li>
<li>Person.prototype에도 hasOwnProperty 메소드가 없으므로 프로토타입 체인을 따라, 다시 말해 __ proto __ 접근자 프로퍼티에 바인딩되어 있는 프로토타입(위 예제의 경우, Object.prototype)으로 이동하여 hasOwnProperty 메소드를 검색한다.</li>
<li>Object.prototype에는 hasOwnProperty 메소드가 존재한다. 자바스크립트 엔진은 Object.prototype.hasOwnProperty 메소드를 호출한다. 이때 Object.prototype.hasOwnProperty 메소드의 this에는 me 객체가 바인딩된다.</li>
</ol>
<br>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></code></pre></div>
<p>프로토타입 체인의 종점인 Object.prototype에서도 프로퍼티를 검색할 수 없는 경우, undefined를 반환한다. 이때 에러가 발생하지 않는 것에 주의하자.</p>
<blockquote>
<p>식별자는 스코프 체인에서 검색한다. 다시말해, 자바스크립트 엔진은 함수의 중첩 관계로 이루어진 스코프의 계층적 구조에서 식별자를 검색한다. 따라서 스코프 체인은 식별자 검색을 위한 메커니즘이라고 할 수 있다.</p>
</blockquote>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">me<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>위 예제의 경우, 먼저 스코프 체인에서 식별자 me를 검색한다. 식별자 me는 전역에서 선언되었으므로 전역 스코프에서 검색된다. 식별자 me를 검색한 다음, me 객체의 프로토타입 체인에서 hasOwnProperty 메소드를 검색한다.</p>
<p>이처럼 <strong>스코프 체인과 프로토타입 체인은 별도로 서로 연관없이 동작하는 것이 아니라 서로 협력하여 식별자와 프로퍼티를 찾아낸다.</strong></p>
<br>
<h2 id="캡슐화"><a href="#%EC%BA%A1%EC%8A%90%ED%99%94" aria-label="캡슐화 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>캡슐화</h2>
<blockquote>
<p>캡슐화를 이해하기 위해서는 변수 또는 함수의 생명주기와 스코프를 이해해야한다.</p>
</blockquote>
<p>추상화 - 어떤 속성들만 포함할 것인가?<br>
상속 - 중복을 어떻게 제거할 것인가?<br>
캡슐화 - 공개할 프로퍼티와 공개하지 않을 프로퍼티를 구별하겠다.(쓴약을 합친 캡슐과 비유) 즉, <strong>정보은폐(상태 또는 메소드의 공개여부)에 관련되었다.</strong> 중첩함수도 캡슐화가 된 예시이다.</p>
<blockquote>
<p><strong>Java에서의 접근 제한자(Class기반 언어)</strong><br>
public(다른 객체의 메소드도 참조할 수 있다), private(Class내부에서만 참조가 가능하다), protected(상속되어있는 객체에만 참조가 가능하다)</p>
</blockquote>
<p><em>자바스크립트는 public, private, protected와 같은 접근 제한자를 제공하지 않는다.</em> 하지만 캡슐화가 불가능한 것은 아니다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 생성자 함수</span>
  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 프로토타입 메소드</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 생성자 함수를 반환</span>
  <span class="token keyword">return</span> Person<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>현재 name 프로퍼티는 현재 외부에서 자유롭게 변경할 수 있게 노출되어 있다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// name 프로퍼티는 public하다. 즉, 외부에서 자유롭게 접근하고 변경할 수 있다.</span>
me<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Kim'</span><span class="token punctuation">;</span>
me<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! My name is Kim</span></code></pre></div>
<p>하지만 캡슐화를 통해 즉시실행함수를 이용해 name을 지역변수로 만들어 외부에서 변경이 불가능하도록 바꿀 수 있다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> _name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token comment">// 함수내부에 있기 때문에 함수스코프로 인해 지역변수를 만들어 변경이 불가능하게 한다.</span>

  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 초기화 되어 _ name에 name을 할당해준다.</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 즉시실행함수 실행할때 person이 바로 생긴다. 생김과 동시에 prototype 객체도 생긴다.</span>

  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>_name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 메소드는 자신이 바라보는 객체가 살아있으면 죽지 않는다.</span>
  <span class="token comment">// 모든 함수는 자신이 생성될때 자신의 상위 스코프를 기억한다.</span>
  <span class="token comment">// 렉시컬 스코프를 생각하면 선언됬을때 스코프환경에서 기억한다. 그래서 _name을 기억하는 것이다.</span>

  <span class="token comment">// 리턴을 안하면 undefined</span>

  <span class="token keyword">return</span> Person<span class="token punctuation">;</span> <span class="token comment">// 리턴을 생성자함수로 리턴</span>
  <span class="token comment">// 리턴하는 동시에 Person.prototype에 sayHi가 들어간다.</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 즉시실행 함수로 만든다, 생성자 함수와 prototype을 하나의 캡슐로 묶어준다.</span>
<span class="token comment">// Person 함수는 살아있다. const Person이 return으로 Person 함수를 할당 받아서 살아 있다. prototype도 살아있다.</span>



<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// _name은 지역 변수이므로 외부에서 참조 및 접근하여 변경할 수 없다. 즉, private하다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//_name is not defined</span>
me<span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token string">'Kim'</span><span class="token punctuation">;</span>

me<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi Lee.</span>
<span class="token comment">// prototype에 저장한 후 sayHi가 죽었기때문에 prototype에는 살아있다</span></code></pre></div>
<p>Person.prototype.sayHello 메소드는 클로저이다. 즉시 실행 함수가 반환하는 생성자 함수가 생성할 객체가 상속받아 호출할 sayHello 메소드는 즉시 실행 함수가 종료한 이후 호출된다. 하지만 sayHello 메소드는 이미 종료되어 소멸한 즉시 실행 함수의 지역 변수 _name을 참조할 수 있다.</p>
<br>
<h2 id="오버라이딩과-프로퍼티-쉐도잉"><a href="#%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%89%90%EB%8F%84%EC%9E%89" aria-label="오버라이딩과 프로퍼티 쉐도잉 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>오버라이딩과 프로퍼티 쉐도잉</h2>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 생성자 함수</span>
  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 프로토타입 메소드</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 생성자 함수를 반환</span>
  <span class="token keyword">return</span> Person<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 인스턴스 메소드</span>
me<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hey! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 인스턴스 메소드가 호출된다. 프로토타입 메소드는 인스턴스 메소드에 의해 가려진다.</span>
me<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hey! My name is Lee</span></code></pre></div>
<p>프로토타입이 소유한 프로퍼티(메소드 포함)를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부른다.</p>
<p>프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다. 이때 인스턴스 메소드 sayHello는 프로토타입 메소드 sayHello를 오버라이딩하였고 프로토타입 메소드 sayHello는 가려진다(프로퍼티 쉐도잉이 된다).</p>
<blockquote>
<p>오버라이딩<br>
상위 객체가 가지고 있는 메소드를 하위 객체가 재정의하여 사용하는 방식</p>
</blockquote>
<p>프로퍼티를 삭제하는 경우에도 마찬가지다.
위 예제에서 추가한 인스턴스 메소드를 sayHellow를 삭제해보면.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 인스턴스 메소드를 삭제한다.</span>
<span class="token keyword">delete</span> me<span class="token punctuation">.</span>sayHello<span class="token punctuation">;</span>
<span class="token comment">// 인스턴스에는 sayHello 메소드가 없으므로 프로토타입 메소드가 호출된다.</span>
me<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! My name is Lee</span></code></pre></div>
<p>당연히 프로토타입 메소드가 아닌 인스턴스 메소드 sayHello가 삭제된다. 다시 한번 sayHello 메소드를 삭제하여 프로토타입 메소드의 삭제를 시도해보자.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 프로토타입 메소드는 삭제되지 않는다.</span>
<span class="token keyword">delete</span> me<span class="token punctuation">.</span>sayHello<span class="token punctuation">;</span>
<span class="token comment">// 프로토타입 메소드가 호출된다.</span>
me<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! My name is Lee</span></code></pre></div>
<p>이와 같이 <em>하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다.</em> 다시 말해 하위 객체를 통해 프로토타입에 get 액세스는 허용되나 set 액세스는 허용되지 않는다.</p>
<p>따라서 프로토타입 프로퍼티를 변경 또는 삭제하려면 하위 객체를 통해 프로토타입 체인으로 접근하는 것이 아니라 프로토타입에 직접 접근하여야 한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 프로토타입 메소드 변경</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hey! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
me<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hey! My name is Lee</span>

<span class="token comment">// 프로토타입 메소드 삭제</span>
<span class="token keyword">delete</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayHello<span class="token punctuation">;</span>
me<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: me.sayHello is not a function</span></code></pre></div>
<br>
<h2 id="프로토타입의-교체"><a href="#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B5%90%EC%B2%B4" aria-label="프로토타입의 교체 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로토타입의 교체</h2>
<h3 id="생성자-함수에-의한-프로토타입의-교체"><a href="#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B5%90%EC%B2%B4" aria-label="생성자 함수에 의한 프로토타입의 교체 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>생성자 함수에 의한 프로토타입의 교체</h3>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 주체는 생성자함수로 프로토타입에 접근해서 프로토타입을 교체한 것 !== Person.prototype.sayHello는 추가하는 것</span>
  <span class="token comment">// 재할당을 의미한다. 즉, prototype을 교체하는 것이다. 이때 constructor의 링크가 깨진다. 그래서 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.</span>


  <span class="token comment">// 그래서 아래와 같이 constructor를 연결해주어야 된다.</span>
  <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// constructor 프로퍼티와 생성자 함수 간의 링크 설정</span>
    constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> Person<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p><strong>그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/d4f244cb08c253b4aa46c87c02832ae2/a1b4d/prototype_object8.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 86.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAEDAgQF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB7NO3WWJE4hIP/8QAGhAAAgIDAAAAAAAAAAAAAAAAAhEBAxAgQf/aAAgBAQABBQLpWBBPD1//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAXEQEAAwAAAAAAAAAAAAAAAAABESAx/9oACAECAQE/AZDaf//EABoQAQABBQAAAAAAAAAAAAAAAAEAAhAgMTL/2gAIAQEABj8C6YjW304//8QAGxABAAICAwAAAAAAAAAAAAAAAQARICExQVH/2gAIAQEAAT8hUgFgTqoCuYk0aslHmH//2gAMAwEAAgADAAAAEFQXPP/EABYRAAMAAAAAAAAAAAAAAAAAAAAQIf/aAAgBAwEBPxAj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAB/8QAHRAAAgICAwEAAAAAAAAAAAAAAREAIRAxQVGhkf/aAAgBAQABPxAU256tDyHhYiBIeRVU13AsiwxxCCCFPuBDT5g7x//Z'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype object"
        title="prototype object"
        src="/static/d4f244cb08c253b4aa46c87c02832ae2/aa03c/prototype_object8.jpg"
        srcset="/static/d4f244cb08c253b4aa46c87c02832ae2/31ba1/prototype_object8.jpg 186w,
/static/d4f244cb08c253b4aa46c87c02832ae2/1160a/prototype_object8.jpg 373w,
/static/d4f244cb08c253b4aa46c87c02832ae2/aa03c/prototype_object8.jpg 745w,
/static/d4f244cb08c253b4aa46c87c02832ae2/a1b4d/prototype_object8.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<hr class="sub" />
<h3 id="인스턴스에-의한-프로토타입의-교체"><a href="#%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%97%90-%EC%9D%98%ED%95%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B5%90%EC%B2%B4" aria-label="인스턴스에 의한 프로토타입의 교체 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>인스턴스에 의한 프로토타입의 교체</h3>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 프로토타입으로 교체할 객체</span>
<span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// ① me 객체의 프로토타입을 parent 객체로 교체한다.</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>me<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 위 코드는 아래의 코드와 동일하게 동작한다.</span>
<span class="token comment">// me.__proto__ = parent;</span>

me<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! My name is Lee</span></code></pre></div>
<p>문제는 constructor가 없고, <em>Person의 prototype속성은 parent를 가리키지 않는다.</em> parent의 constructor가 없어서 Object.prototype으로 간다. 따라서 프로토타입의 constructor프로퍼티로 me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token comment">// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p>생성자 함수에 의한 프로토타입 교체와 마찬가지로 인스턴스에 의한 프로토타입 교체도 constructor 프로퍼티와 생성자 함수 간의 연결을 파괴한다.</p>
<p><strong>그림으로 나타내면</strong>
<span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 745px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/e2cc5e565544e7c390898f9ea64ca04f/a1b4d/prototype_object9.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 86.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAEDAgQF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB7NO3WWgnEJB//8QAGBAAAgMAAAAAAAAAAAAAAAAAAQIDIEH/2gAIAQEAAQUC1pEDX//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABcRAQADAAAAAAAAAAAAAAAAAAERIDH/2gAIAQIBAT8BkNp//8QAGhABAAEFAAAAAAAAAAAAAAAAAQACECAxMv/aAAgBAQAGPwLpiNbfTj//xAAZEAEBAQADAAAAAAAAAAAAAAABEQAgMUH/2gAIAQEAAT8hUwFgTyY6yaxlOP8A/9oADAMBAAIAAwAAABBUxzz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EAH/xAAbEAEBAAMBAQEAAAAAAAAAAAABEQAhMRChUf/aAAgBAQABPxArtrzcPmPCyIUPmMSjRO4bTZTcxMkGr+4cJ498/9k='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="prototype object"
        title="prototype object"
        src="/static/e2cc5e565544e7c390898f9ea64ca04f/aa03c/prototype_object9.jpg"
        srcset="/static/e2cc5e565544e7c390898f9ea64ca04f/31ba1/prototype_object9.jpg 186w,
/static/e2cc5e565544e7c390898f9ea64ca04f/1160a/prototype_object9.jpg 373w,
/static/e2cc5e565544e7c390898f9ea64ca04f/aa03c/prototype_object9.jpg 745w,
/static/e2cc5e565544e7c390898f9ea64ca04f/a1b4d/prototype_object9.jpg 750w"
        sizes="(max-width: 745px) 100vw, 745px"
        loading="lazy"
      />
  </a>
    </span></p>
<br>
<h2 id="instanceof-연산자"><a href="#instanceof-%EC%97%B0%EC%82%B0%EC%9E%90" aria-label="instanceof 연산자 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>instanceof 연산자</h2>
<p>instanceof 연산자는 이항 연산자로서 좌변에 객체를 가기키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아닌 경우, TypeError가 발생한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">객체 <span class="token keyword">instanceof</span> 생성자 함수</code></pre></div>
<p>좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스라면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다. instanceof 연산자는 상속 관계를 고려한다는 것에 주의하기 바란다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// me 객체는 Person 생성자 함수에 의해 생성된 인스턴스이다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// instanceof 연산자는 상속 관계를 고려한다.</span>
<span class="token comment">// me 객체는 Object.prototype을 상속받기 때문에 아래의 코드는 true로 평가된다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<br>
<h2 id="직접-상속"><a href="#%EC%A7%81%EC%A0%91-%EC%83%81%EC%86%8D" aria-label="직접 상속 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>직접 상속</h2>
<h3 id="objectcreate에-의한-직접-상속"><a href="#objectcreate%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A7%81%EC%A0%91-%EC%83%81%EC%86%8D" aria-label="objectcreate에 의한 직접 상속 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object.create에 의한 직접 상속</h3>
<p>Object.create(생성할 객체의 프로토타입(필수), 생성할 프로퍼티의 정의)를 사용하는 이유는 프로토타입 체인을 교체하면서
객체를 만들때 사용한다.</p>
<p>프로토타입의 종점에 있는 객체로 만들 수 있기 때문에 object.prototpye에 있는 메소드를 직접 실행하는 것은 위험하다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 프로토타입이 null(최상위)인 객체를 생성한다.</span>
<span class="token comment">// 즉, 생성된 객체는 프로토타입 체인의 종점이므로 프로토타입 체인이 생성되지 않는다.</span>
<span class="token comment">// obj → null</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// Object.prototype를 상속받지 못한다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: obj.toString is not a function</span>

<span class="token keyword">const</span> myProto <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 객체를 직접 상속받는다.</span>
<span class="token comment">// obj → myProto → Object.prototype → null</span>
obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>myProto<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> myProto<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span> <span class="token comment">// Object, Object.prototype의 constructor는 Object이기 때문이다.</span></code></pre></div>
<ul>
<li>new 연산자가 없이도 객체를 생성할 수 있다.</li>
<li>프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생성자 함수와 프로토타입 간의 링크가 파괴되지 않는다.</li>
<li>객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있다.</li>
</ul>
<p>object.create함수를 아느냐 모르느냐
object.create쓰면 prototype 체인의 종점에 있는 프로토타입을 만들 수 있다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// true , Object.prototype에 있는 메소드이다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">propertyIsEnumerable</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p>객체 프로토타입은 실질적으로 프로토타입이 없는 경우도 있으므로 위의 코드는 사용을 하지 않는 것이 좋다.</p>
<hr class="sub" />
<h3 id="객체-리터럴-내부에서-proto에-의한-직접-상속"><a href="#%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-proto%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A7%81%EC%A0%91-%EC%83%81%EC%86%8D" aria-label="객체 리터럴 내부에서 proto에 의한 직접 상속 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>객체 리터럴 내부에서 <strong>proto</strong>에 의한 직접 상속</h3>
<p>Object.create 메소드는 직접 상속은 위와 같이 여러 장점이 있다. 하지만 두번째 인자로 프로퍼티를 정의하는 것은 번거롭다. 일단 객체를 생성한 이후, 프로퍼티를 추가하는 방법도 있으나 이 또한 깔끔한 방법은 아니다.</p>
<p>ES6에서는 객체 리터럴 내부에서 __ proto __ 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> myProto <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  y<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  <span class="token comment">// 객체를 직접 상속받는다.</span>
  <span class="token comment">// obj → myProto → Object.prototype → null</span>
  __proto__<span class="token punctuation">:</span> myProto
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 위 코드는 아래와 동일하다.</span>
<span class="token comment">// const obj = Object.create(myProto, { y: { value: 20 } });</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>x<span class="token punctuation">,</span> obj<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10 20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> myProto<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<br>
<h2 id="정적-프로퍼티메소드"><a href="#%EC%A0%95%EC%A0%81-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A9%94%EC%86%8C%EB%93%9C" aria-label="정적 프로퍼티메소드 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정적 프로퍼티/메소드</h2>
<p>정적(static) 프로퍼티/메소드는 생성자 함수로 <strong>인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다.</strong> 아래 예제를 살펴보자.</p>
<p>함수는 객체이므로</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

foo<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 가능하다.</span>
foo<span class="token punctuation">.</span><span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 가능하다, 함수도 메소드를 가질 수 있다.</span>

<span class="token comment">// 한마디로 생성자함수에도 메소드를 추가 할 수 있다. 생성자함수가 가지는 메소드를 정적메소드라 칭한다.</span>
<span class="token comment">// 생성자 함수</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 프로토타입 메소드</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Person 생성자 함수는 객체이므로 자신의 프로퍼티/메소드를 소유할 수 있다.</span>
<span class="token comment">// 정적 프로퍼티</span>
Person<span class="token punctuation">.</span>staticProp <span class="token operator">=</span> <span class="token string">'static prop'</span><span class="token punctuation">;</span>
<span class="token comment">// 정적 메소드</span>
Person<span class="token punctuation">.</span><span class="token function-variable function">staticMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'staticMethod'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Lee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 생성자 함수에 추가한 정적 프로퍼티/메소드는 생성자 함수로 참조/호출한다.</span>
Person<span class="token punctuation">.</span><span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// staticMethod</span>

<span class="token comment">// 정적 프로퍼티/메소드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.</span>
<span class="token comment">// 인스턴스로 참조/호출할 수 있는 프로퍼티/메소드는 프로토타입 체인 상에 존재해야 한다.</span>
me<span class="token punctuation">.</span><span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: me.staticMethod is not a function</span></code></pre></div>
<br>
<h2 id="프로퍼티-존재-확인"><a href="#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A1%B4%EC%9E%AC-%ED%99%95%EC%9D%B8" aria-label="프로퍼티 존재 확인 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로퍼티 존재 확인</h2>
<p>프로퍼티이름(문자열) in 대상 식별자
원래 프로퍼티이름은 문자열로 저장된다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Lee'</span><span class="token punctuation">,</span>
  address<span class="token punctuation">:</span> <span class="token string">'Seoul'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'toString'</span> <span class="token keyword">in</span> person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div>
<p>in 연산자 상속 관계에 있는 모든 프로퍼티를 다 본다.</p>
<p>상속빼고 자기 자신만 보고 싶다면
<strong>hasOwnProperty</strong>을 쓴다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre></div>
<br>
<h2 id="프로퍼티-열거"><a href="#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%97%B4%EA%B1%B0" aria-label="프로퍼티 열거 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프로퍼티 열거</h2>
<p>순회하면서 하나씩 하나씩 볼 수 있는지 여부</p>
<h3 id="forin문"><a href="#forin%EB%AC%B8" aria-label="forin문 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>for…in문</h3>
<p>객체 자신의 프로퍼티만을 열거하기 위해서는 for…in 문을 사용하는 것 보다 Object.keys/values/entries 메소드를 사용하는 것을 권장한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> prop <span class="token keyword">in</span> person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>prop <span class="token operator">+</span> <span class="token string">': '</span> <span class="token operator">+</span> person<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// const는 for문이 돌때마다 변수 선언이 이루어지므로 let이 아니여도 된다.</span></code></pre></div>
<hr class="sub" />
<h3 id="objectkeysvaluesentries-메소드"><a href="#objectkeysvaluesentries-%EB%A9%94%EC%86%8C%EB%93%9C" aria-label="objectkeysvaluesentries 메소드 permalink" class="anchor"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object.keys/values/entries 메소드</h3>
<p>객체 자신의 프로퍼티만을 열거하기 위해서는 for…in 문을 사용하는 것 보다 Object.keys/values/entries 메소드를 사용하는 것을 권장한다.</p>
<p>keys : 배열로 키들을 반환한다.
values : 배열로 값들을 반환한다.
entries : 배열로 키와 값을 묶어서 반환한다.</p>
<p>Object.keys 메소드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Lee'</span><span class="token punctuation">,</span>
  address<span class="token punctuation">:</span> <span class="token string">'Seoul'</span><span class="token punctuation">,</span>
  __proto__<span class="token punctuation">:</span> <span class="token punctuation">{</span> age<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["name", "address"]</span></code></pre></div>
<p>Object.values(ES8) 메소드는 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Lee", "Seoul"]</span></code></pre></div>
<p>Object.entries(ES8) 메소드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [["name", "Lee"], ["address", "Seoul"]]</span></code></pre></div>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<div class="reference-site">
<p>  <strong>Reference</strong><br></p>
<p>  <a href="https://poiemaweb.com" target="_blank" rel="nofollow noopener noreferrer">https://poiemaweb.com</a></p>
</div></div></div></div><div class="Post-module--post__footer--1BvmJ"><div><p class="Meta-module--meta__date--3FNDv">Published <!-- -->20 Oct 2019</p></div><div class="Tags-module--tags--1oNz4"><ul class="Tags-module--tags__list--2UTD-"><li class="Tags-module--tags__list-item--b7tap"><a class="Tags-module--tags__list-item-link--1hQL0" href="/tag/prototype/">prototype</a></li><li class="Tags-module--tags__list-item--b7tap"><a class="Tags-module--tags__list-item-link--1hQL0" href="/tag/proto/">proto</a></li></ul></div><div class="Author-module--author--2kf8a"><p>Publee&#x27;s velog</p></div></div><div class="Post-module--post__comments--2T8dL"><div><div id="disqus_thread"></div></div></div></div></div><svg viewBox="0 0 24 24" height="2.5em" width="2.5em" aria-hidden="true" focusable="false" fill="currentColor" xmlns="http://www.w3.org/2000/svg" direction="up" class="StyledIconBase-sc-bdy9j4 jbPeIR sc-bdVaJa bZttKe"><path fill="none" d="M0 0h24v24H0z"></path><path d="M12 23a7.5 7.5 0 01-5.138-12.963C8.204 8.774 11.5 6.5 11 1.5c6 4 9 8 3 14 1 0 2.5 0 5-2.47.27.773.5 1.604.5 2.47A7.5 7.5 0 0112 23z"></path></svg></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-147413543-1', 'auto', {});
      
      
      
      
      
      }</script><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/posts/javascript/prototype";window.webpackCompilationHash="404c815bd30c1c274720";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-b5ef2b8caa37ca4e0f53.js"],"component---node-modules-gatsby-plugin-offline-app-shell-js":["/component---node-modules-gatsby-plugin-offline-app-shell-js-9f3ca7f208d9f49af53a.js"],"component---src-templates-not-found-template-js":["/component---src-templates-not-found-template-js-35d8fd22e59001113069.js"],"component---src-templates-tags-list-template-js":["/component---src-templates-tags-list-template-js-ab989528dc3be1dcddaf.js"],"component---src-templates-categories-list-template-js":["/component---src-templates-categories-list-template-js-86a06990eea93efae2e8.js"],"component---src-templates-page-template-js":["/component---src-templates-page-template-js-e49fd51703bd1dd05bf1.js"],"component---src-templates-post-template-js":["/component---src-templates-post-template-js-101fb2c27a0a2ef5a3cd.js"],"component---src-templates-tag-template-js":["/component---src-templates-tag-template-js-c3faac5fa95e2f4fc520.js"],"component---src-templates-category-template-js":["/component---src-templates-category-template-js-0138adf92f2b303ec517.js"],"component---src-templates-index-template-js":["/component---src-templates-index-template-js-bfa4cbbb7295964b388a.js"]};/*]]>*/</script><script src="/component---src-templates-post-template-js-101fb2c27a0a2ef5a3cd.js" async=""></script><script src="/commons-d334a8000d62581fb129.js" async=""></script><script src="/styles-fbc6349a203ed4bcd9e6.js" async=""></script><script src="/app-b5ef2b8caa37ca4e0f53.js" async=""></script><script src="/webpack-runtime-3b57bb17d138b785ccb6.js" async=""></script></body></html>